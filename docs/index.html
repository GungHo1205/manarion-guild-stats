<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guild Stats Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    <script>
      // Required to find the wasm file
      const config = {
        locateFile: (filename) =>
          `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${filename}`,
      };
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-primary: #0a0a0b;
        --bg-secondary: #1a1a1b;
        --bg-tertiary: #2a2a2b;
        --text-primary: #f8f9fa;
        --text-secondary: #b3b3b3;
        --accent: #4a9eff;
        --border: #3a3a3b;
        --shadow: rgba(0, 0, 0, 0.5);
        --success: #4ade80;
        --warning: #fbbf24;
        --error: #f87171;
        --favorite: #fbbf24;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Inter", sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        line-height: 1.6;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .navbar {
        display: flex;
        justify-content: center;
        background: var(--bg-secondary);
        padding: 8px;
        border-radius: 12px;
        margin-bottom: 30px;
        border: 1px solid var(--border);
        flex-wrap: wrap;
      }
      .nav-link {
        color: var(--text-secondary);
        text-decoration: none;
        padding: 10px 20px;
        margin: 5px;
        border-radius: 8px;
        transition: all 0.3s;
        font-weight: 600;
        cursor: pointer;
      }
      .nav-link:hover {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
      }
      .nav-link.active {
        background-color: var(--accent);
        color: #fff;
      }
      .important-notice {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-left: 4px solid var(--warning);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 30px;
        position: relative;
      }

      .notice-header {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--warning);
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .notice-header::before {
        content: "⚠";
        font-size: 1.2rem;
      }

      .notice-content {
        font-size: 0.95rem;
        color: var(--text-secondary);
        line-height: 1.6;
        max-width: none;
        margin: 0;
        font-weight: 400;
      }
      .page-section {
        display: none;
      }
      .page-section.active {
        display: block;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
      }
      .header h1 {
        font-size: 2.5rem;
        font-weight: 800;
      }
      .header p {
        color: var(--text-secondary);
        font-size: 1.1rem;
      }

      .stats-overview {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
      }
      .stat-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 25px;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .stat-card h3 {
        font-size: 2.2rem;
        font-weight: 700;
        margin-bottom: 8px;
      }
      .stat-card p {
        color: var(--text-secondary);
        font-size: 0.9rem;
        font-weight: 500;
        margin-bottom: 8px;
      }
      .stat-card .sub-text {
        font-size: 0.85rem;
        color: var(--text-secondary);
        min-height: 1.2em;
      }
      .stat-card .approximation-note {
        font-size: 0.7rem;
        color: var(--text-secondary);
        opacity: 0.6;
        margin-top: 12px;
      }

      .controls {
        margin-bottom: 30px;
        display: flex;
        gap: 20px;
        align-items: center;
        flex-wrap: wrap;
      }
      .search-box {
        flex: 1;
        max-width: 400px;
        position: relative;
      }
      .search-box input {
        width: 100%;
        padding: 12px 20px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 1rem;
      }
      .last-update {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-left: auto;
      }
      .data-freshness {
        margin-top: 4px;
      }
      .fresh-data {
        color: var(--success);
      }
      .stale-data {
        color: var(--warning);
      }

      .guild-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
        gap: 25px;
      }
      .guild-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 25px;
        position: relative;
      }
      .guild-card.favorite {
        border-color: var(--favorite);
        background: linear-gradient(
          135deg,
          var(--bg-secondary) 0%,
          rgba(251, 191, 36, 0.1) 100%
        );
      }
      .guild-name {
        font-size: 1.3rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .favorite-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2rem;
        color: var(--text-secondary);
        transition: all 0.3s;
        padding: 5px;
        border-radius: 4px;
      }
      .favorite-btn:hover {
        background: var(--bg-tertiary);
        color: var(--favorite);
      }
      .favorite-btn.favorited {
        color: var(--favorite);
      }
      .level-info {
        display: flex;
        justify-content: space-around;
        margin-top: 15px;
      }
      .level-item {
        text-align: center;
      }
      .level-label {
        font-size: 0.85rem;
        color: var(--text-secondary);
      }
      .level-value {
        font-size: 2rem;
        font-weight: 700;
      }
      .daily-change {
        font-size: 0.8rem;
        font-weight: 600;
      }
      .daily-change.positive {
        color: var(--success);
      }

      .loading,
      .error {
        text-align: center;
        padding: 60px;
        font-size: 1.2rem;
      }
      .error {
        color: var(--error);
      }

      .chart-container {
        background: var(--bg-secondary);
        border-radius: 15px;
        padding: 25px;
        border: 1px solid var(--border);
      }
      .chart-header {
        text-align: center;
        margin-bottom: 30px;
      }
      .chart-header h1 {
        font-size: 2.2rem;
        font-weight: 700;
      }
      .chart-header p {
        color: var(--text-secondary);
        font-size: 1rem;
      }

      .chart-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 25px;
      }
      .control-group {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
      }
      .chart-controls button,
      .dust-timespan-btn {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px 14px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.3s;
        white-space: nowrap;
        text-align: center;
      }
      .chart-controls button:hover,
      .dust-timespan-btn:hover {
        border-color: var(--accent);
      }
      .chart-controls button.active,
      .dust-timespan-btn.active {
        background-color: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .chart-canvas-container {
        position: relative;
        height: 450px;
        margin-top: 20px;
      }

      .multiselect-dropdown {
        position: relative;
        min-width: 250px;
      }
      .multiselect-dropdown-btn {
        background: var(--bg-tertiary);
        width: 100%;
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid var(--border);
        cursor: pointer;
        text-align: left;
        font-weight: 500;
        color: var(--text-primary);
      }
      .multiselect-dropdown-list {
        display: none;
        position: absolute;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 8px;
        width: 100%;
        z-index: 10;
        max-height: 300px;
        overflow-y: auto;
        padding: 8px;
        margin-top: 5px;
        box-shadow: 0 4px 12px var(--shadow);
      }
      .multiselect-dropdown-list label {
        display: block;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        color: var(--text-primary);
      }
      .multiselect-dropdown-list label:hover {
        background-color: var(--bg-tertiary);
      }
      .multiselect-dropdown-list input {
        margin-right: 10px;
      }
      .multiselect-dropdown-list label.favorite-guild {
        color: var(--favorite);
        font-weight: 600;
      }

      .item-selector {
        position: relative;
        min-width: 300px;
      }
      .item-select-btn {
        background: var(--bg-tertiary);
        width: 100%;
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid var(--border);
        cursor: pointer;
        text-align: left;
        font-weight: 500;
        color: var(--text-primary);
      }
      .item-select-dropdown {
        display: none;
        position: absolute;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 8px;
        width: 100%;
        z-index: 10;
        max-height: 400px;
        overflow-y: auto;
        padding: 8px;
        margin-top: 5px;
        box-shadow: 0 4px 12px var(--shadow);
      }
      .item-select-dropdown input {
        width: 100%;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 6px;
        color: var(--text-primary);
        margin-bottom: 8px;
      }
      .item-category {
        margin-bottom: 12px;
      }
      .category-header {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--accent);
        padding: 8px;
        background: var(--bg-tertiary);
        border-radius: 4px;
        margin-bottom: 4px;
      }
      .item-option {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        color: var(--text-primary);
        font-size: 0.85rem;
      }
      .item-option:hover {
        background: var(--bg-tertiary);
      }

      .chart-loading {
        text-align: center;
        padding: 100px;
        color: var(--text-secondary);
        font-size: 1.1rem;
      }

      .aggregation-controls {
        margin-left: 20px;
        padding-left: 20px;
        border-left: 1px solid var(--border);
      }

      .aggregation-controls label {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-right: 10px;
      }

      .aggregation-controls select {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 0.9rem;
      }

      /* Price Predictor Styles */
      .predictor-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 30px;
      }

      .prediction-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 25px;
      }

      .prediction-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
      }

      .prediction-metric {
        text-align: center;
        padding: 20px;
        background: var(--bg-tertiary);
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .prediction-metric h4 {
        font-size: 1.8rem;
        font-weight: 700;
        margin-bottom: 5px;
      }

      .prediction-metric p {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .predictor-period-btn {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px 14px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.3s;
        white-space: nowrap;
        text-align: center;
      }

      .predictor-period-btn:hover {
        border-color: var(--accent);
      }

      .predictor-period-btn.active {
        background-color: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .trend-up {
        color: var(--success);
      }

      .trend-down {
        color: var(--error);
      }

      .trend-stable {
        color: var(--warning);
      }

      .testing-disclaimer {
        background: var(--bg-tertiary);
        border-left: 4px solid var(--warning);
        padding: 15px 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .testing-disclaimer strong {
        color: var(--warning);
        font-weight: 600;
      }

      /* Leaderboard Styles */
      .leaderboard-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      .leaderboard-btn {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px 20px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: all 0.3s;
        white-space: nowrap;
      }

      .leaderboard-btn:hover {
        border-color: var(--accent);
        background: var(--bg-secondary);
      }

      .leaderboard-btn.active {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .leaderboard-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
        gap: 25px;
      }

      .leaderboard-item {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 25px;
        display: flex;
        align-items: center;
        gap: 20px;
        position: relative;
      }

      .leaderboard-rank {
        font-size: 2rem;
        font-weight: 800;
        color: var(--accent);
        min-width: 60px;
        text-align: center;
      }

      .leaderboard-rank.gold {
        color: #ffd700;
      }
      .leaderboard-rank.silver {
        color: #c0c0c0;
      }
      .leaderboard-rank.bronze {
        color: #cd7f32;
      }

      .leaderboard-info {
        flex: 1;
      }

      .leaderboard-guild {
        font-size: 1.3rem;
        font-weight: 600;
        margin-bottom: 5px;
      }

      .leaderboard-stat {
        font-size: 1.1rem;
        color: var(--text-secondary);
      }

      .leaderboard-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: var(--success);
      }

      /* New styles for Mana Calculator for consistency */
      .calculator-form-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 30px;
        max-width: 700px;
        margin: 0 auto 30px auto;
        display: flex;
        gap: 15px;
        align-items: center;
        justify-content: center;
      }

      .calculator-form-card .search-box {
        flex: 1;
        max-width: 400px;
      }

      .calculator-form-card .search-box input {
        text-align: center;
        font-size: 1.1rem;
        padding: 14px 20px;
      }

      .calculator-form-card .calculate-btn {
        background: var(--accent);
        color: #fff;
        border: 1px solid var(--accent);
        border-radius: 12px;
        padding: 14px 28px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: all 0.3s;
        white-space: nowrap;
      }

      .calculator-form-card .calculate-btn:hover {
        opacity: 0.9;
      }

      @media (max-width: 768px) {
        .navbar {
          justify-content: flex-start;
        }
        .chart-controls,
        .predictor-controls {
          flex-direction: column;
          align-items: stretch;
        }
        .control-group {
          justify-content: center;
        }
        .item-selector {
          min-width: auto;
        }
        .aggregation-controls {
          margin-left: 0;
          padding-left: 0;
          border-left: none;
          border-top: 1px solid var(--border);
          padding-top: 15px;
          margin-top: 15px;
        }
        .leaderboard-controls {
          flex-direction: column;
          align-items: stretch;
        }
        .leaderboard-item {
          flex-direction: column;
          text-align: center;
        }
        .calculator-form-card {
          flex-direction: column;
          align-items: stretch;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav class="navbar">
        <a class="nav-link active" data-section="dashboard">Dashboard</a>
        <a class="nav-link" data-section="nexus-charts">Nexus Progress</a>
        <a class="nav-link" data-section="study-charts">Study Progress</a>
        <a class="nav-link" data-section="item-prices">Item Prices</a>
        <a class="nav-link" data-section="price-predictor"
          >Item Price Predictor</a
        >
        <a class="nav-link" data-section="leaderboards">Leaderboards</a>
        <a class="nav-link" data-section="mana-calculator"
          >Mana Dust Calculator</a
        >
      </nav>

      <!-- Dashboard Section -->
      <div id="dashboard" class="page-section active">
        <header class="header">
          <h1>Guild Stats Dashboard</h1>
          <p>Real-time guild progression tracking</p>
        </header>

        <div class="important-notice">
          <div class="notice-header">Important Data Accuracy Notice</div>
          <div class="notice-content">
            Study levels are inaccurate. Gathering pets increase study levels
            according to pet level. Please check the leader of the guild and
            subtract the bonus exp from the pet to get the correct study room
            level.
          </div>
        </div>

        <div class="stats-overview">
          <div class="stat-card">
            <h3 id="stat-avg-nexus">-</h3>
            <p>Avg Nexus Level</p>
            <div id="stat-avg-nexus-progress" class="sub-text"></div>
          </div>
          <div class="stat-card">
            <h3 id="stat-avg-study">-</h3>
            <p>Avg Study Level</p>
            <div id="stat-avg-study-progress" class="sub-text"></div>
          </div>
          <div class="stat-card">
            <h3 id="stat-levels-gained">-</h3>
            <p>Levels Gained Today</p>
            <div class="sub-text"></div>
          </div>
          <div class="stat-card">
            <h3 id="stat-codex-used">-</h3>
            <p>Total Codex Used (Daily)</p>
            <div class="sub-text"></div>
            <div class="approximation-note">
              Approximation without Ethereal Refinery
            </div>
          </div>
          <div class="stat-card">
            <h3 id="stat-dust-spent">-</h3>
            <p>Dust Spent on Codex (Daily)</p>
            <div id="stat-dust-spent-price" class="sub-text"></div>
            <div class="approximation-note">
              Approximation without Ethereal Refinery
            </div>
          </div>
        </div>

        <div class="controls">
          <div class="search-box">
            <input
              type="text"
              id="searchInput"
              placeholder="Search guilds..."
            />
          </div>
          <div class="last-update" id="lastUpdate">
            <div>Loading...</div>
            <div id="dataFreshness" class="data-freshness"></div>
          </div>
        </div>

        <div id="loading" class="loading">Loading guild data...</div>
        <div id="error" class="error" style="display: none">
          Failed to load data.
        </div>
        <div id="guildGrid" class="guild-grid" style="display: none"></div>
      </div>

      <!-- Nexus Chart Section -->
      <div id="nexus-charts" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Nexus Level Progression</h1>
            <p>Track guild nexus level changes over time</p>
          </div>
          <div class="chart-controls">
            <div class="multiselect-dropdown">
              <button
                id="nexusGuildSelectorBtn"
                class="multiselect-dropdown-btn"
              >
                Loading guilds...
              </button>
              <div
                id="nexusGuildSelectorList"
                class="multiselect-dropdown-list"
              ></div>
            </div>
            <div class="control-group">
              <button
                class="chart-timespan-btn active"
                data-chart="nexus"
                data-hours="24"
              >
                1D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="nexus"
                data-hours="72"
              >
                3D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="nexus"
                data-hours="168"
              >
                7D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="nexus"
                data-hours="336"
              >
                14D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="nexus"
                data-hours="720"
              >
                30D
              </button>
            </div>
            <div class="aggregation-controls">
              <label for="nexusAggregation">View:</label>
              <select id="nexusAggregation">
                <option value="auto">Auto</option>
                <option value="hourly">Hourly</option>
                <option value="daily">Daily</option>
              </select>
            </div>
          </div>
          <div id="nexusChartLoading" class="chart-loading">
            Loading chart data...
          </div>
          <div class="chart-canvas-container" style="display: none">
            <canvas id="guildNexusChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Study Chart Section -->
      <div id="study-charts" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Study Level Progression</h1>
            <p>Track guild study level changes over time</p>
          </div>
          <div class="chart-controls">
            <div class="multiselect-dropdown">
              <button
                id="studyGuildSelectorBtn"
                class="multiselect-dropdown-btn"
              >
                Loading guilds...
              </button>
              <div
                id="studyGuildSelectorList"
                class="multiselect-dropdown-list"
              ></div>
            </div>
            <div class="control-group">
              <button
                class="chart-timespan-btn active"
                data-chart="study"
                data-hours="24"
              >
                1D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="study"
                data-hours="72"
              >
                3D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="study"
                data-hours="168"
              >
                7D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="study"
                data-hours="336"
              >
                14D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="study"
                data-hours="720"
              >
                30D
              </button>
            </div>
            <div class="aggregation-controls">
              <label for="studyAggregation">View:</label>
              <select id="studyAggregation">
                <option value="auto">Auto</option>
                <option value="hourly">Hourly</option>
                <option value="daily">Daily</option>
              </select>
            </div>
          </div>
          <div id="studyChartLoading" class="chart-loading">
            Loading chart data...
          </div>
          <div class="chart-canvas-container" style="display: none">
            <canvas id="guildStudyChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Item Prices Section -->
      <div id="item-prices" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Item Price History</h1>
            <p>Monitor market prices for tradeable items</p>
          </div>
          <div class="chart-controls">
            <div class="item-selector">
              <button id="itemSelectBtn" class="item-select-btn">
                Loading items...
              </button>
              <div id="itemSelectDropdown" class="item-select-dropdown">
                <input
                  type="text"
                  id="itemSearchInput"
                  placeholder="Search items..."
                />
                <div id="itemList"></div>
              </div>
            </div>
            <div class="control-group">
              <button class="market-timespan-btn active" data-hours="24">
                1D
              </button>
              <button class="market-timespan-btn" data-hours="72">3D</button>
              <button class="market-timespan-btn" data-hours="168">7D</button>
              <button class="market-timespan-btn" data-hours="336">14D</button>
              <button class="market-timespan-btn" data-hours="720">30D</button>
            </div>
            <div class="aggregation-controls">
              <label for="marketAggregation">View:</label>
              <select id="marketAggregation">
                <option value="auto">Auto</option>
                <option value="hourly">Hourly</option>
                <option value="daily">Daily</option>
              </select>
            </div>
          </div>
          <div id="marketChartLoading" class="chart-loading">
            Loading chart data...
          </div>
          <div class="chart-canvas-container" style="display: none">
            <canvas id="marketPriceChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Price Predictor Section -->
      <div id="price-predictor" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Item Price Predictor</h1>
            <p>AI-powered market analysis and price forecasting</p>
          </div>

          <div class="testing-disclaimer">
            <strong>Testing Phase:</strong> This price prediction feature is
            experimental and in active testing. Predictions should not be
            considered certain or guaranteed to happen. Use at your own
            discretion and always verify market conditions independently.
          </div>

          <div class="predictor-controls">
            <div class="item-selector">
              <button id="predictorItemSelectBtn" class="item-select-btn">
                Loading items...
              </button>
              <div
                id="predictorItemSelectDropdown"
                class="item-select-dropdown"
              >
                <input
                  type="text"
                  id="predictorItemSearchInput"
                  placeholder="Search items..."
                />
                <div id="predictorItemList"></div>
              </div>
            </div>
            <div class="control-group">
              <button class="predictor-period-btn active" data-days="3">
                3 Days
              </button>
              <button class="predictor-period-btn" data-days="7">7 Days</button>
              <button class="predictor-period-btn" data-days="14">
                14 Days
              </button>
              <button class="predictor-period-btn" data-days="30">
                30 Days
              </button>
            </div>
          </div>

          <div id="predictionLoading" class="chart-loading">
            Select an item to see price predictions...
          </div>
          <div id="predictionResults" style="display: none">
            <div class="prediction-card">
              <div class="prediction-summary">
                <div class="prediction-metric">
                  <h4 id="currentPrice">-</h4>
                  <p>Current Average Price</p>
                </div>
                <div class="prediction-metric">
                  <h4 id="predictedPrice">-</h4>
                  <p>Predicted Price</p>
                </div>
                <div class="prediction-metric">
                  <h4 id="priceChange">-</h4>
                  <p>Expected Change</p>
                </div>
              </div>
            </div>
            <div class="chart-canvas-container">
              <canvas id="predictionChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <!-- Leaderboards Section -->
      <div id="leaderboards" class="page-section">
        <header class="header">
          <h1>Guild Leaderboards</h1>
          <p>Rankings based on daily progress and achievements</p>
        </header>

        <div class="leaderboard-controls">
          <button class="leaderboard-btn active" data-type="codex">
            Most Codex Spent
          </button>
          <button class="leaderboard-btn" data-type="nexus">
            Top Nexus Upgrades
          </button>
          <button class="leaderboard-btn" data-type="study">
            Top Study Upgrades
          </button>
          <button class="leaderboard-btn" data-type="dust">
            Daily Dust Income
          </button>
        </div>

        <!-- Sub-controls for the dust leaderboard -->
        <div
          id="dustLeaderboardControls"
          class="chart-controls"
          style="display: none; justify-content: center; margin-bottom: 30px"
        >
          <div class="control-group">
            <button class="dust-timespan-btn" data-days="1">1D</button>
            <button class="dust-timespan-btn" data-days="3">3D</button>
            <button class="dust-timespan-btn active" data-days="7">7D</button>
            <button class="dust-timespan-btn" data-days="14">14D</button>
            <button class="dust-timespan-btn" data-days="30">30D</button>
          </div>
        </div>

        <div id="leaderboardLoading" class="loading">
          Loading leaderboard data...
        </div>
        <div
          id="leaderboardContent"
          class="leaderboard-list"
          style="display: none"
        ></div>
      </div>

      <!-- Mana Dust Calculator Section -->
      <div id="mana-calculator" class="page-section">
        <header class="header">
          <h1>Mana Dust Income Calculator</h1>
          <p>
            Estimate a player's mana dust income based on their current stats.
          </p>
        </header>

        <div class="calculator-form-card">
          <div class="search-box">
            <input
              type="text"
              id="playerNameInput"
              placeholder="Enter player name (e.g., matthi)"
            />
          </div>
          <button id="calculateManaDustBtn" class="calculate-btn">
            Calculate
          </button>
        </div>

        <div
          id="manaCalculatorNotice"
          class="important-notice"
          style="
            display: none;
            margin-top: 20px;
            border-left-color: var(--accent);
          "
        >
          <div
            id="manaCalculatorNoticeContent"
            class="notice-content"
            style="color: var(--text-secondary)"
          ></div>
        </div>

        <div id="manaCalculatorLoading" class="loading" style="display: none">
          Fetching player data and calculating...
        </div>
        <div id="manaCalculatorError" class="error" style="display: none">
          <!-- Error messages will appear here -->
        </div>

        <div
          id="manaCalculatorResults"
          class="stats-overview"
          style="display: none; margin-top: 40px"
        >
          <!-- Results will be injected here by JavaScript -->
        </div>
      </div>
    </div>

    <script>
      // Global State
      let allGuildsData = [];
      let db; // The in-browser database instance
      let guildNexusChart, guildStudyChart, marketPriceChart, predictionChart;
      let dataLoaded = false;
      let favoriteGuilds = JSON.parse(
        localStorage.getItem("favoriteGuilds") || "[]"
      );

      const chartColors = [
        "#ec4899",
        "#38bdf8",
        "#4ade80",
        "#a78bfa",
        "#fde047",
        "#fb923c",
        "#f87171",
        "#34d399",
        "#fbbf24",
        "#c084fc",
      ];

      // --- Database Initialization ---
      async function initializeDatabase() {
        try {
          const SQL = await initSqlJs(config);
          const dbFile = await fetch(
            `./guild-stats.db?v=${new Date().getTime()}`
          );
          const dbBuffer = await dbFile.arrayBuffer();
          db = new SQL.Database(new Uint8Array(dbBuffer));
          console.log("Database loaded successfully.");
          return true;
        } catch (error) {
          console.error("Failed to initialize database:", error);
          document.getElementById("loading").textContent =
            "Failed to load database. Please refresh.";
          document.getElementById("error").style.display = "block";
          return false;
        }
      }

      // Initialization
      document.addEventListener("DOMContentLoaded", async () => {
        const dbReady = await initializeDatabase();
        if (dbReady) {
          loadAllData();
          setupEventListeners();
        }
      });

      async function loadAllData() {
        try {
          const latestSnapshotQuery = `
            SELECT * FROM (
                SELECT *, ROW_NUMBER() OVER(PARTITION BY guild_name ORDER BY timestamp DESC) as rn
                FROM guild_snapshots
            ) WHERE rn = 1;
          `;
          const latestGuildsResult = db.exec(latestSnapshotQuery);

          if (!latestGuildsResult || latestGuildsResult.length === 0) {
            throw new Error("No guild data found in the database.");
          }

          const columns = latestGuildsResult[0].columns;
          allGuildsData = latestGuildsResult[0].values.map((row) => {
            let guild = {};
            columns.forEach((col, i) => {
              guild[col] = row[i];
            });
            guild.GuildName = guild.guild_name;
            guild.NexusLevel = guild.nexus_level;
            guild.StudyLevel = guild.study_level;
            guild.NexusProgress = guild.nexus_progress;
            guild.StudyProgress = guild.study_progress;
            guild.TotalCodexCost = guild.codex_cost;
            return guild;
          });

          updateDashboard();
          renderGuilds();
          populateGuildSelectors();
          populateItemSelector();
          populatePredictorItemSelector();

          document.getElementById("loading").style.display = "none";
          document.getElementById("guildGrid").style.display = "grid";
          dataLoaded = true;

          document.getElementById("nexusChartLoading").style.display = "none";
          document.getElementById("studyChartLoading").style.display = "none";
          document.getElementById("marketChartLoading").style.display = "none";

          updateLeaderboard("codex");
        } catch (error) {
          console.error("Error loading data from DB:", error);
          document.getElementById("loading").style.display = "none";
          document.getElementById("error").style.display = "block";
          document.getElementById(
            "error"
          ).textContent = `Error loading data: ${error.message}`;
        }
      }

      function setupEventListeners() {
        document
          .querySelectorAll(".nav-link")
          .forEach((link) => link.addEventListener("click", handleNavigation));
        document
          .getElementById("searchInput")
          .addEventListener("input", renderGuilds);

        document.querySelectorAll(".chart-timespan-btn").forEach((btn) =>
          btn.addEventListener("click", (e) => {
            const chartType = e.target.dataset.chart;
            document
              .querySelectorAll(`#${chartType}-charts .chart-timespan-btn`)
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            updateGuildChart(chartType);
          })
        );

        document.querySelectorAll(".market-timespan-btn").forEach((btn) =>
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".market-timespan-btn")
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            updateMarketChart();
          })
        );

        document.querySelectorAll(".predictor-period-btn").forEach((btn) =>
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".predictor-period-btn")
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            updatePrediction();
          })
        );

        // --- MODIFIED: Leaderboard Event Listeners ---
        document.querySelectorAll(".leaderboard-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".leaderboard-btn")
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            const type = e.target.dataset.type;

            document.getElementById("dustLeaderboardControls").style.display =
              type === "dust" ? "flex" : "none";
            document.getElementById("leaderboardContent").style.display =
              "none";
            document.getElementById("leaderboardLoading").style.display =
              "block";

            if (type === "dust") {
              updateDustLeaderboard();
            } else {
              updateLeaderboard(type);
            }
          });
        });

        document.querySelectorAll(".dust-timespan-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".dust-timespan-btn")
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            updateDustLeaderboard();
          });
        });
        // --- End of Modified Listeners ---

        document
          .getElementById("nexusAggregation")
          .addEventListener("change", () => updateGuildChart("nexus"));
        document
          .getElementById("studyAggregation")
          .addEventListener("change", () => updateGuildChart("study"));
        document
          .getElementById("marketAggregation")
          .addEventListener("change", () => updateMarketChart());

        setupDropdown("nexusGuildSelectorBtn", "nexusGuildSelectorList", () =>
          updateGuildChart("nexus")
        );
        setupDropdown("studyGuildSelectorBtn", "studyGuildSelectorList", () =>
          updateGuildChart("study")
        );
        setupDropdown("itemSelectBtn", "itemSelectDropdown");
        setupDropdown("predictorItemSelectBtn", "predictorItemSelectDropdown");

        document
          .getElementById("itemSearchInput")
          .addEventListener("input", filterItems);
        document
          .getElementById("predictorItemSearchInput")
          .addEventListener("input", filterPredictorItems);

        document
          .getElementById("calculateManaDustBtn")
          .addEventListener("click", handleManaDustCalculation);
        document
          .getElementById("playerNameInput")
          .addEventListener("keyup", (event) => {
            if (event.key === "Enter") {
              handleManaDustCalculation();
            }
          });
      }

      function setupDropdown(btnId, listId, onChangeCallback) {
        const btn = document.getElementById(btnId);
        const list = document.getElementById(listId);
        btn.addEventListener("click", () => {
          const isVisible = list.style.display === "block";
          document
            .querySelectorAll(
              ".multiselect-dropdown-list, .item-select-dropdown"
            )
            .forEach((d) => (d.style.display = "none"));
          list.style.display = isVisible ? "none" : "block";
        });
        if (onChangeCallback) list.addEventListener("change", onChangeCallback);
        document.addEventListener("click", (e) => {
          if (!btn.contains(e.target) && !list.contains(e.target)) {
            list.style.display = "none";
          }
        });
      }

      function handleNavigation(e) {
        e.preventDefault();
        const targetId = e.target.getAttribute("data-section");
        document
          .querySelectorAll(".nav-link")
          .forEach((l) => l.classList.remove("active"));
        e.target.classList.add("active");
        document
          .querySelectorAll(".page-section")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById(targetId).classList.add("active");

        if (dataLoaded) {
          if (targetId === "nexus-charts" && !guildNexusChart)
            setTimeout(() => updateGuildChart("nexus"), 100);
          if (targetId === "study-charts" && !guildStudyChart)
            setTimeout(() => updateGuildChart("study"), 100);
          if (targetId === "item-prices" && !marketPriceChart)
            setTimeout(() => updateMarketChart(), 100);
          if (targetId === "leaderboards") {
            const activeBtn = document.querySelector(".leaderboard-btn.active");
            if (activeBtn) {
              const type = activeBtn.dataset.type;
              if (type === "dust") {
                updateDustLeaderboard();
              } else {
                updateLeaderboard(type);
              }
            }
          }
        }
      }

      function toggleFavorite(guildName) {
        const index = favoriteGuilds.indexOf(guildName);
        if (index > -1) favoriteGuilds.splice(index, 1);
        else favoriteGuilds.push(guildName);
        localStorage.setItem("favoriteGuilds", JSON.stringify(favoriteGuilds));
        renderGuilds();
        populateGuildSelectors();
      }

      function isFavorite(guildName) {
        return favoriteGuilds.includes(guildName);
      }

      function sortGuildsByFavorite(guilds) {
        return guilds.sort((a, b) => {
          const aFav = isFavorite(a.GuildName);
          const bFav = isFavorite(b.GuildName);
          if (aFav && !bFav) return -1;
          if (!aFav && bFav) return 1;
          return (b.NexusLevel || 0) - (a.NexusLevel || 0);
        });
      }

      function updateDashboard() {
        if (!allGuildsData || allGuildsData.length === 0) return;
        const avg = (key) =>
          allGuildsData.reduce((sum, g) => sum + (g[key] || 0), 0) /
          allGuildsData.length;
        const sum = (key) =>
          allGuildsData.reduce((sum, g) => sum + (g[key] || 0), 0);
        const totalCodexUsed = sum("TotalCodexCost");

        const codexPriceResult = db.exec(
          "SELECT AVG(average_price) FROM market_prices WHERE item_name = 'Codex'"
        );
        const avgCodexPrice =
          codexPriceResult[0]?.values[0]?.[0] || 10000000000;

        document.getElementById("stat-avg-nexus").textContent =
          avg("NexusLevel").toFixed(1);
        document.getElementById(
          "stat-avg-nexus-progress"
        ).innerHTML = `<span class="daily-change positive">+${avg(
          "NexusProgress"
        ).toFixed(1)} Today</span>`;
        document.getElementById("stat-avg-study").textContent =
          avg("StudyLevel").toFixed(1);
        document.getElementById(
          "stat-avg-study-progress"
        ).innerHTML = `<span class="daily-change positive">+${avg(
          "StudyProgress"
        ).toFixed(1)} Today</span>`;
        document.getElementById("stat-levels-gained").textContent =
          sum("NexusProgress") + sum("StudyProgress");
        document.getElementById("stat-codex-used").textContent =
          totalCodexUsed.toLocaleString();
        document.getElementById("stat-dust-spent").textContent =
          ((totalCodexUsed * avgCodexPrice) / 1e12).toFixed(2) + "T";
        document.getElementById("stat-dust-spent-price").textContent = `@ ${(
          avgCodexPrice / 1e9
        ).toFixed(2)}B per Codex`;

        const lastUpdateResult = db.exec(
          "SELECT timestamp FROM processing_logs ORDER BY timestamp DESC LIMIT 1"
        );
        const baselineResult = db.exec(
          "SELECT created_at FROM daily_baselines ORDER BY date DESC LIMIT 1"
        );
        const lastUpdated = lastUpdateResult[0]?.values[0]?.[0];
        const baselineCreatedAt = baselineResult[0]?.values[0]?.[0];

        if (lastUpdated && baselineCreatedAt) {
          const lastUpdateTime = new Date(lastUpdated).toLocaleString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          });
          const dailyBaselineDate = new Date(baselineCreatedAt).toLocaleString(
            "en-US",
            {
              year: "numeric",
              month: "long",
              day: "numeric",
              hour: "numeric",
              minute: "2-digit",
              hour12: true,
            }
          );
          document.getElementById(
            "lastUpdate"
          ).innerHTML = `<div>Last updated: ${lastUpdateTime}</div><div class="data-freshness">Daily baseline date: ${dailyBaselineDate}</div>`;
        }
      }

      function renderGuilds() {
        const searchTerm = document
          .getElementById("searchInput")
          .value.toLowerCase();
        let filtered = allGuildsData.filter((g) =>
          g.GuildName.toLowerCase().includes(searchTerm)
        );
        filtered = sortGuildsByFavorite(filtered);
        const grid = document.getElementById("guildGrid");
        if (filtered.length === 0) {
          grid.innerHTML =
            "<p style='text-align: center; color: var(--text-secondary); grid-column: 1/-1;'>No guilds found.</p>";
          return;
        }
        grid.innerHTML = filtered
          .map(
            (g) => `
          <div class="guild-card ${isFavorite(g.GuildName) ? "favorite" : ""}">
            <div class="guild-name">
              <span>${g.GuildName}</span>
              <button class="favorite-btn ${
                isFavorite(g.GuildName) ? "favorited" : ""
              }" onclick="toggleFavorite('${g.GuildName}')" title="${
              isFavorite(g.GuildName)
                ? "Remove from favorites"
                : "Add to favorites"
            }">
                ${isFavorite(g.GuildName) ? "★" : "☆"}
              </button>
            </div>
            <div class="level-info">
              <div class="level-item"><div class="level-label">Nexus</div><div class="level-value">${
                g.NexusLevel || 0
              }</div><div class="daily-change positive">+${
              g.NexusProgress || 0
            }</div></div>
              <div class="level-item"><div class="level-label">Study</div><div class="level-value">${
                g.StudyLevel || 0
              }</div><div class="daily-change positive">+${
              g.StudyProgress || 0
            }</div></div>
            </div>
          </div>
        `
          )
          .join("");
      }

      function populateGuildSelectors() {
        const result = db.exec(
          "SELECT DISTINCT guild_name FROM guild_snapshots ORDER BY guild_name"
        );
        if (!result || result.length === 0) return;
        const guildNames = result[0].values.flat();

        const sortedGuildNames = guildNames.sort((a, b) => {
          const aFav = isFavorite(a);
          const bFav = isFavorite(b);
          if (aFav && !bFav) return -1;
          if (!aFav && bFav) return 1;
          const guildA = allGuildsData.find((g) => g.GuildName === a);
          const guildB = allGuildsData.find((g) => g.GuildName === b);
          return (guildB?.NexusLevel || 0) - (guildA?.NexusLevel || 0);
        });

        let autoSelectGuilds =
          favoriteGuilds.length > 0
            ? favoriteGuilds
            : [
                "Doomed",
                "Spaghetti and Meatballs",
                "RNG",
                "Divinity",
                "Sanctuary",
                "Phoenix",
                "Codex",
                "EZ",
              ];
        ["nexus", "study"].forEach((type) => {
          const list = document.getElementById(`${type}GuildSelectorList`);
          list.innerHTML = sortedGuildNames
            .map(
              (name) =>
                `<label class="${
                  isFavorite(name) ? "favorite-guild" : ""
                }"><input type="checkbox" value="${name}" ${
                  autoSelectGuilds.includes(name) ? "checked" : ""
                }> ${isFavorite(name) ? "★ " : ""}${name}</label>`
            )
            .join("");
          updateSelectedGuildCount(type);
        });
      }

      function updateSelectedGuildCount(type) {
        const list = document.getElementById(`${type}GuildSelectorList`);
        const btn = document.getElementById(`${type}GuildSelectorBtn`);
        const count = list.querySelectorAll("input:checked").length;
        btn.textContent = `${count} Guild${count !== 1 ? "s" : ""} Selected`;
      }

      function updateGuildChart(chartType) {
        updateSelectedGuildCount(chartType);
        const selectedGuilds = Array.from(
          document.querySelectorAll(
            `#${chartType}GuildSelectorList input:checked`
          )
        ).map((cb) => cb.value);
        if (selectedGuilds.length === 0) return;

        const hours = parseInt(
          document.querySelector(
            `#${chartType}-charts .chart-timespan-btn.active`
          ).dataset.hours
        );
        const cutoff = new Date(Date.now() - hours * 3600 * 1000).toISOString();
        const aggregation = document.getElementById(
          `${chartType}Aggregation`
        ).value;
        const useDaily =
          aggregation === "daily" || (aggregation === "auto" && hours >= 168);

        const datasets = selectedGuilds.map((name, i) => {
          const query = `SELECT timestamp, ${chartType}_level FROM guild_snapshots WHERE guild_name = :guildName AND timestamp >= :cutoff ORDER BY timestamp`;
          const stmt = db.prepare(query);
          stmt.bind({ ":guildName": name, ":cutoff": cutoff });
          let guildData = [];
          while (stmt.step()) guildData.push(stmt.getAsObject());
          stmt.free();

          let filteredData = guildData.map((d) => ({
            x: d.timestamp,
            y: d[`${chartType}_level`],
          }));
          if (useDaily && filteredData.length > 0)
            filteredData = aggregateDataByDay(filteredData);

          return {
            label: name,
            data: filteredData,
            borderColor: chartColors[i % chartColors.length],
            tension: 0.1,
            backgroundColor: chartColors[i % chartColors.length] + "20",
            pointRadius: useDaily ? 3 : 2,
            pointHoverRadius: useDaily ? 5 : 4,
          };
        });

        const canvasId =
          chartType === "nexus" ? "guildNexusChart" : "guildStudyChart";
        const chartInstance =
          chartType === "nexus" ? guildNexusChart : guildStudyChart;
        if (chartInstance) chartInstance.destroy();
        const newChart = new Chart(
          document.getElementById(canvasId).getContext("2d"),
          {
            type: "line",
            data: { datasets },
            options: getChartOptions(hours, false, useDaily),
          }
        );
        if (chartType === "nexus") guildNexusChart = newChart;
        else guildStudyChart = newChart;
        document.querySelector(
          `#${chartType}-charts .chart-canvas-container`
        ).style.display = "block";
      }

      function populateItemSelector() {
        const result = db.exec(
          "SELECT DISTINCT item_name FROM market_prices ORDER BY item_name"
        );
        if (!result || result.length === 0) {
          document.getElementById("itemSelectBtn").textContent =
            "No items found";
          return;
        }
        const items = result[0].values.flat();
        const itemList = document.getElementById("itemList");
        itemList.innerHTML = items
          .map(
            (itemName) =>
              `<div class="item-option" data-item="${itemName}">${itemName}</div>`
          )
          .join("");

        document.querySelectorAll("#itemList .item-option").forEach((option) =>
          option.addEventListener("click", () => {
            document.getElementById("itemSelectBtn").textContent =
              option.textContent;
            document.getElementById("itemSelectBtn").dataset.selected =
              option.dataset.item;
            document.getElementById("itemSelectDropdown").style.display =
              "none";
            updateMarketChart();
          })
        );

        const defaultOption =
          document.querySelector('.item-option[data-item="Codex"]') ||
          document.querySelector(".item-option");
        if (defaultOption) {
          document.getElementById("itemSelectBtn").textContent =
            defaultOption.textContent;
          document.getElementById("itemSelectBtn").dataset.selected =
            defaultOption.dataset.item;
        }
      }

      function filterItems() {
        const term = document
          .getElementById("itemSearchInput")
          .value.toLowerCase();
        document.querySelectorAll("#itemList .item-option").forEach((opt) => {
          const matches = opt.textContent.toLowerCase().includes(term);
          opt.style.display = matches ? "block" : "none";
        });
      }

      function populatePredictorItemSelector() {
        const result = db.exec(
          "SELECT DISTINCT item_name FROM market_prices ORDER BY item_name"
        );
        if (!result || result.length === 0) return;
        const items = result[0].values.flat();
        const itemList = document.getElementById("predictorItemList");
        itemList.innerHTML = items
          .map(
            (itemName) =>
              `<div class="item-option" data-item="${itemName}">${itemName}</div>`
          )
          .join("");

        document
          .querySelectorAll("#predictorItemList .item-option")
          .forEach((option) => {
            option.addEventListener("click", () => {
              document.getElementById("predictorItemSelectBtn").textContent =
                option.textContent;
              document.getElementById(
                "predictorItemSelectBtn"
              ).dataset.selected = option.dataset.item;
              document.getElementById(
                "predictorItemSelectDropdown"
              ).style.display = "none";
              updatePrediction();
            });
          });

        const defaultOption =
          document.querySelector(
            '#predictorItemList .item-option[data-item="Codex"]'
          ) || document.querySelector("#predictorItemList .item-option");
        if (defaultOption) {
          document.getElementById("predictorItemSelectBtn").textContent =
            defaultOption.textContent;
          document.getElementById("predictorItemSelectBtn").dataset.selected =
            defaultOption.dataset.item;
        }
      }

      function filterPredictorItems() {
        const term = document
          .getElementById("predictorItemSearchInput")
          .value.toLowerCase();
        document
          .querySelectorAll("#predictorItemList .item-option")
          .forEach((opt) => {
            opt.style.display = opt.textContent.toLowerCase().includes(term)
              ? "block"
              : "none";
          });
      }

      function updateMarketChart() {
        const selectedItem =
          document.getElementById("itemSelectBtn").dataset.selected;
        if (!selectedItem) return;

        const hours = parseInt(
          document.querySelector("#item-prices .market-timespan-btn.active")
            .dataset.hours
        );
        const cutoff = new Date(Date.now() - hours * 3600 * 1000).toISOString();

        const query =
          "SELECT timestamp, buy_price, sell_price FROM market_prices WHERE item_name = :itemName AND timestamp >= :cutoff ORDER BY timestamp";
        const stmt = db.prepare(query);
        stmt.bind({ ":itemName": selectedItem, ":cutoff": cutoff });
        let prices = [];
        while (stmt.step()) prices.push(stmt.getAsObject());
        stmt.free();

        if (prices.length === 0) return;

        const aggregation = document.getElementById("marketAggregation").value;
        const useDaily =
          aggregation === "daily" || (aggregation === "auto" && hours >= 168);
        if (useDaily) prices = aggregateMarketDataByDay(prices);

        const datasets = [
          {
            label: "Buy Price",
            data: prices.map((p) => ({ x: p.timestamp, y: p.buy_price })),
            borderColor: "#4ade80",
            backgroundColor: "#4ade8020",
            tension: 0.1,
          },
          {
            label: "Sell Price",
            data: prices.map((p) => ({ x: p.timestamp, y: p.sell_price })),
            borderColor: "#f87171",
            backgroundColor: "#f8717120",
            tension: 0.1,
          },
        ];
        datasets.forEach((ds) => {
          ds.pointRadius = useDaily ? 3 : 2;
          ds.pointHoverRadius = useDaily ? 5 : 4;
        });

        if (marketPriceChart) marketPriceChart.destroy();
        marketPriceChart = new Chart(
          document.getElementById("marketPriceChart").getContext("2d"),
          {
            type: "line",
            data: { datasets },
            options: getChartOptions(hours, true, useDaily),
          }
        );
        document.querySelector(
          "#item-prices .chart-canvas-container"
        ).style.display = "block";
      }

      // --- MODIFIED: Leaderboard function uses SQL, now handles codex, nexus, study ---
      function updateLeaderboard(type) {
        document.getElementById("leaderboardLoading").style.display = "block";
        const contentDiv = document.getElementById("leaderboardContent");
        contentDiv.style.display = "none";
        contentDiv.innerHTML = "";

        let valueKey = "",
          formatValue = (val) => val;

        switch (type) {
          case "codex":
            valueKey = "codex_cost";
            formatValue = (val) => (val || 0).toLocaleString() + " Codex";
            break;
          case "nexus":
            valueKey = "nexus_progress";
            formatValue = (val) => "+" + (val || 0) + " Levels";
            break;
          case "study":
            valueKey = "study_progress";
            formatValue = (val) => "+" + (val || 0) + " Levels";
            break;
        }

        if (!valueKey) {
          console.error("updateLeaderboard called with invalid type:", type);
          document.getElementById("leaderboardLoading").style.display = "none";
          return;
        }

        const query = `
            SELECT guild_name, ${valueKey} FROM (
                SELECT *, ROW_NUMBER() OVER(PARTITION BY guild_name ORDER BY timestamp DESC) as rn
                FROM guild_snapshots
            ) WHERE rn = 1 AND ${valueKey} > 0 ORDER BY ${valueKey} DESC;
        `;
        const result = db.exec(query);
        if (!result || result.length === 0 || result[0].values.length === 0) {
          contentDiv.innerHTML = `<p style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">No progress data available for this category today.</p>`;
        } else {
          const columns = result[0].columns;
          const sortedGuilds = result[0].values.map((row) => {
            let guild = {};
            columns.forEach((col, i) => (guild[col] = row[i]));
            return guild;
          });

          contentDiv.innerHTML = sortedGuilds
            .map((guild, index) => {
              const rank = index + 1;
              let rankClass = "",
                rankDisplay = `${rank}th`;
              if (rank === 1) {
                rankClass = "gold";
                rankDisplay = "1st";
              } else if (rank === 2) {
                rankClass = "silver";
                rankDisplay = "2nd";
              } else if (rank === 3) {
                rankClass = "bronze";
                rankDisplay = "3rd";
              }

              const guildName = guild.guild_name;
              return `
                <div class="leaderboard-item ${
                  isFavorite(guildName) ? "favorite" : ""
                }">
                  <div class="leaderboard-rank ${rankClass}">${rankDisplay}</div>
                  <div class="leaderboard-info">
                    <div class="leaderboard-guild">${
                      isFavorite(guildName) ? "★ " : ""
                    }${guildName}</div>
                    <div class="leaderboard-stat"><span class="leaderboard-value">${formatValue(
                      guild[valueKey]
                    )}</span></div>
                  </div>
                </div>`;
            })
            .join("");
        }

        document.getElementById("leaderboardLoading").style.display = "none";
        contentDiv.style.display = "grid";
      }

      // --- NEW: Function to load Daily Dust Income leaderboard ---
      async function updateDustLeaderboard() {
        const contentDiv = document.getElementById("leaderboardContent");
        const loadingDiv = document.getElementById("leaderboardLoading");

        loadingDiv.style.display = "block";
        contentDiv.style.display = "none";
        contentDiv.innerHTML = ""; // Clear previous results

        try {
          const days = document.querySelector(".dust-timespan-btn.active")
            .dataset.days;
          const startDate = new Date();
          startDate.setDate(startDate.getDate() - parseInt(days));
          const startDateString = startDate.toISOString().split("T")[0]; // YYYY-MM-DD

          const query = `
                SELECT
                    player_name,
                    AVG(daily_income) as avg_income
                FROM
                    player_dust_income
                WHERE
                    date >= :startDate
                GROUP BY
                    player_name
                HAVING
                    AVG(daily_income) > 0
                ORDER BY
                    avg_income DESC
                LIMIT 100;
            `;
          const stmt = db.prepare(query);
          stmt.bind({ ":startDate": startDateString });

          let results = [];
          while (stmt.step()) {
            results.push(stmt.getAsObject());
          }
          stmt.free();

          if (results.length === 0) {
            contentDiv.innerHTML = `<p style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary);">No dust income data found for the selected period.</p>`;
          } else {
            contentDiv.innerHTML = results
              .map((player, index) => {
                const rank = index + 1;
                let rankClass = "",
                  rankDisplay = `${rank}th`;
                if (rank === 1) {
                  rankClass = "gold";
                  rankDisplay = "1st";
                } else if (rank === 2) {
                  rankClass = "silver";
                  rankDisplay = "2nd";
                } else if (rank === 3) {
                  rankClass = "bronze";
                  rankDisplay = "3rd";
                }

                return `
                    <div class="leaderboard-item">
                      <div class="leaderboard-rank ${rankClass}">${rankDisplay}</div>
                      <div class="leaderboard-info">
                        <div class="leaderboard-guild">${
                          player.player_name
                        }</div>
                        <div class="leaderboard-stat">
                           <span class="leaderboard-value">${formatDustValue(
                             player.avg_income
                           )}</span> / day avg
                        </div>
                      </div>
                    </div>`;
              })
              .join("");
          }
        } catch (e) {
          console.error("Error loading dust leaderboard:", e);
          contentDiv.innerHTML = `<p style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--error);">Failed to load dust leaderboard data.</p>`;
        } finally {
          loadingDiv.style.display = "none";
          contentDiv.style.display = "grid";
        }
      }

      function formatDustValue(amount) {
        if (amount >= 1e12) return (amount / 1e12).toFixed(2) + "T";
        if (amount >= 1e9) return (amount / 1e9).toFixed(2) + "B";
        if (amount >= 1e6) return (amount / 1e6).toFixed(2) + "M";
        if (amount >= 1e3) return (amount / 1e3).toFixed(2) + "K";
        return amount.toLocaleString(undefined, {
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
        });
      }

      function updatePrediction() {
        const selectedItem = document.getElementById("predictorItemSelectBtn")
          .dataset.selected;
        if (!selectedItem) {
          document.getElementById("predictionLoading").style.display = "block";
          document.getElementById("predictionResults").style.display = "none";
          return;
        }

        const days = parseInt(
          document.querySelector(".predictor-period-btn.active").dataset.days
        );
        const cutoff = new Date(
          Date.now() - days * 24 * 3600 * 1000
        ).toISOString();

        const query =
          "SELECT buy_price, sell_price, timestamp FROM market_prices WHERE item_name = :itemName AND timestamp >= :cutoff ORDER BY timestamp";
        const stmt = db.prepare(query);
        stmt.bind({ ":itemName": selectedItem, ":cutoff": cutoff });
        let prices = [];
        while (stmt.step()) prices.push(stmt.getAsObject());
        stmt.free();

        if (prices.length < 2) return;

        const remappedPrices = prices.map((p) => ({
          buy: p.buy_price,
          sell: p.sell_price,
          timestamp: p.timestamp,
        }));

        const prediction = calculatePrediction(remappedPrices);
        displayPrediction(selectedItem, prediction, remappedPrices);
      }

      function calculatePrediction(prices) {
        const recent = prices.slice(-24);
        const currentAvg =
          recent.reduce((sum, p) => sum + (p.buy + p.sell) / 2, 0) /
          recent.length;
        const values = prices.map((p, i) => ({
          x: i,
          y: (p.buy + p.sell) / 2,
        }));
        const n = values.length;
        const sumX = values.reduce((sum, v) => sum + v.x, 0);
        const sumY = values.reduce((sum, v) => sum + v.y, 0);
        const sumXY = values.reduce((sum, v) => sum + v.x * v.y, 0);
        const sumX2 = values.reduce((sum, v) => sum + v.x * v.x, 0);
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        const predictedPrice = slope * n + intercept;
        const priceChange = ((predictedPrice - currentAvg) / currentAvg) * 100;
        let trend = "stable";
        if (Math.abs(priceChange) > 5) trend = priceChange > 0 ? "up" : "down";
        return {
          currentPrice: currentAvg,
          predictedPrice: predictedPrice,
          priceChange: priceChange,
          trend: trend,
        };
      }

      function displayPrediction(itemName, prediction, prices) {
        document.getElementById("predictionLoading").style.display = "none";
        document.getElementById("predictionResults").style.display = "block";
        document.getElementById("currentPrice").textContent = formatCurrency(
          prediction.currentPrice
        );
        document.getElementById("predictedPrice").textContent = formatCurrency(
          prediction.predictedPrice
        );
        const changeElement = document.getElementById("priceChange");
        changeElement.textContent = `${
          prediction.priceChange >= 0 ? "+" : ""
        }${prediction.priceChange.toFixed(1)}%`;
        changeElement.className = `trend-${prediction.trend}`;
        updatePredictionChart(itemName, prices, prediction);
      }

      function updatePredictionChart(itemName, prices, prediction) {
        const historicalData = prices.map((p) => ({
          x: p.timestamp,
          y: (p.buy + p.sell) / 2,
        }));
        const futureTime = new Date(
          Date.now() + 24 * 3600 * 1000
        ).toISOString();
        const predictionPoint = { x: futureTime, y: prediction.predictedPrice };
        const datasets = [
          {
            label: "Historical Average Price",
            data: historicalData,
            borderColor: "#4a9eff",
            backgroundColor: "#4a9eff20",
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 4,
          },
          {
            label: "Prediction",
            data: [historicalData[historicalData.length - 1], predictionPoint],
            borderColor: "#fbbf24",
            backgroundColor: "#fbbf2440",
            borderDash: [5, 5],
            tension: 0,
            pointRadius: 4,
            pointHoverRadius: 6,
          },
        ];
        if (predictionChart) predictionChart.destroy();
        predictionChart = new Chart(
          document.getElementById("predictionChart").getContext("2d"),
          {
            type: "line",
            data: { datasets },
            options: {
              ...getChartOptions(
                24 *
                  parseInt(
                    document.querySelector(".predictor-period-btn.active")
                      .dataset.days
                  ),
                true,
                false
              ),
              plugins: {
                ...getChartOptions(24, true, false).plugins,
                title: {
                  display: true,
                  text: `${itemName} Price Prediction`,
                  color: "#f8f9fa",
                  font: { size: 16, weight: "bold" },
                },
              },
            },
          }
        );
      }

      async function handleManaDustCalculation() {
        const playerName = document
          .getElementById("playerNameInput")
          .value.trim();
        if (!playerName) {
          showManaCalculatorError("Please enter a player name.");
          return;
        }

        const loadingDiv = document.getElementById("manaCalculatorLoading");
        const errorDiv = document.getElementById("manaCalculatorError");
        const resultsDiv = document.getElementById("manaCalculatorResults");
        const noticeDiv = document.getElementById("manaCalculatorNotice");

        loadingDiv.style.display = "block";
        errorDiv.style.display = "none";
        resultsDiv.style.display = "none";
        noticeDiv.style.display = "none";

        try {
          const playerNameLower = playerName.toLowerCase();
          const apiUrl = `https://api.manarion.com/players/${playerNameLower}`;
          const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(
            apiUrl
          )}`;
          const response = await fetch(proxyUrl);

          if (!response.ok) {
            throw new Error(
              `Failed to fetch data from the API proxy. Status: ${response.status}`
            );
          }

          const responseText = await response.text();
          let playerData;

          try {
            playerData = JSON.parse(responseText);
          } catch (jsonError) {
            console.error("Failed to parse player data as JSON.", jsonError);
            throw new Error(`Player '${playerName}' not found.`);
          }

          let calculationNotice = "";

          const totalBoostsObject = playerData.TotalBoosts || {};
          const baseManaDustRaw = Number(totalBoostsObject["101"]);
          if (!isFinite(baseManaDustRaw))
            calculationNotice +=
              "Could not find Base Mana Dust Boost (ID 101), defaulting to 0%. ";

          const manaDustRaw = Number(totalBoostsObject["121"]);
          if (!isFinite(manaDustRaw))
            calculationNotice +=
              "Could not find Mana Dust Boost (ID 121), defaulting to 0%. ";

          const baseFactor =
            1 + (isFinite(baseManaDustRaw) ? baseManaDustRaw : 0) / 100;
          const totalFactor =
            1 + (isFinite(manaDustRaw) ? manaDustRaw : 0) / 100;

          const enemyLevel = playerData.Enemy;
          let enemyBaseManaDrop;
          if (enemyLevel > 150000) {
            const baseAt150k =
              0.0001 * Math.pow(150150, 2) +
              Math.pow(150150, 1.2) +
              10 * 150150;
            const multiplier = Math.pow(1.01, (enemyLevel - 150000) / 2000);
            enemyBaseManaDrop = multiplier * baseAt150k;
          } else {
            const x = enemyLevel + 150;
            enemyBaseManaDrop =
              0.0001 * Math.pow(x, 2) + Math.pow(x, 1.2) + 10 * x;
          }

          const finalDropPerKill = enemyBaseManaDrop * baseFactor * totalFactor;
          const killsPerHour = 3600 / 3;
          const incomePerHour = finalDropPerKill * killsPerHour;
          const incomePerDay = incomePerHour * 24;

          renderManaDustResults(
            {
              perKill: finalDropPerKill,
              perHour: incomePerHour,
              perDay: incomePerDay,
              perWeek: incomePerDay * 7,
              perMonth: incomePerDay * 30,
            },
            calculationNotice.trim()
          );
        } catch (error) {
          console.error("Mana Dust Calculator Error:", error);
          showManaCalculatorError(error.message);
        } finally {
          loadingDiv.style.display = "none";
        }
      }

      function renderManaDustResults(income, notice = "") {
        const resultsDiv = document.getElementById("manaCalculatorResults");
        const noticeDiv = document.getElementById("manaCalculatorNotice");
        const noticeContent = document.getElementById(
          "manaCalculatorNoticeContent"
        );

        resultsDiv.innerHTML = `
            <div class="stat-card"><h3>${formatManaDust(
              income.perKill
            )}</h3><p>Per Kill (3s)</p></div>
            <div class="stat-card"><h3>${formatManaDust(
              income.perHour
            )}</h3><p>Per Hour</p></div>
            <div class="stat-card"><h3>${formatManaDust(
              income.perDay
            )}</h3><p>Per Day</p></div>
            <div class="stat-card"><h3>${formatManaDust(
              income.perWeek
            )}</h3><p>Per Week</p></div>
            <div class="stat-card"><h3>${formatManaDust(
              income.perMonth
            )}</h3><p>Per Month (30d)</p></div>
        `;

        if (notice) {
          noticeContent.textContent = `Note: ${notice} The calculation below reflects these defaults.`;
          noticeDiv.style.display = "block";
        } else {
          noticeDiv.style.display = "none";
        }
        resultsDiv.style.display = "grid";
      }

      function showManaCalculatorError(message) {
        const errorDiv = document.getElementById("manaCalculatorError");
        errorDiv.textContent = message;
        errorDiv.style.display = "block";
        document.getElementById("manaCalculatorResults").style.display = "none";
        document.getElementById("manaCalculatorNotice").style.display = "none";
      }

      function formatManaDust(amount) {
        if (typeof amount !== "number" || !isFinite(amount)) return "0.00";
        if (amount < 1000)
          return amount.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          });
        const tier = Math.floor(Math.log10(Math.abs(amount)) / 3);
        const suffix = [
          "",
          "K",
          "M",
          "B",
          "T",
          "q",
          "Q",
          "s",
          "S",
          "O",
          "N",
          "D",
          "UD",
          "DD",
          "TD",
          "qD",
          "QD",
          "sD",
          "SD",
          "OD",
          "ND",
          "V",
          "UV",
          "DV",
          "TV",
          "qV",
          "QV",
          "sV",
          "SV",
          "OV",
          "NV",
          "t",
          "ut",
          "dt",
          "tt",
        ][tier];
        if (!suffix) return amount.toExponential(2);
        const scale = Math.pow(10, tier * 3);
        return (amount / scale).toFixed(2) + suffix;
      }

      // --- UTILITY FUNCTIONS ---
      function aggregateDataByDay(data) {
        const dailyData = {};
        data.forEach((point) => {
          const date = new Date(point.x).toDateString();
          if (!dailyData[date])
            dailyData[date] = { values: [], timestamp: point.x };
          dailyData[date].values.push(point.y);
        });
        return Object.values(dailyData)
          .map((day) => ({
            x: day.timestamp,
            y: Math.round(day.values[day.values.length - 1]),
          }))
          .sort((a, b) => new Date(a.x) - new Date(b.x));
      }

      function aggregateMarketDataByDay(prices) {
        const dailyData = {};
        prices.forEach((price) => {
          const date = new Date(price.timestamp).toDateString();
          if (!dailyData[date])
            dailyData[date] = { buy: [], sell: [], timestamp: price.timestamp };
          dailyData[date].buy.push(price.buy_price);
          dailyData[date].sell.push(price.sell_price);
        });
        return Object.values(dailyData)
          .map((day) => ({
            timestamp: day.timestamp,
            buy_price: Math.round(day.buy[day.buy.length - 1]),
            sell_price: Math.round(day.sell[day.sell.length - 1]),
          }))
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      }

      function getChartOptions(hours, isCurrency, useDaily = false) {
        return {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: "index" },
          scales: {
            x: {
              type: "time",
              time: {
                unit: useDaily ? "day" : hours <= 72 ? "hour" : "day",
                displayFormats: { hour: "MMM dd HH:mm", day: "MMM dd" },
              },
              ticks: { color: "#b3b3b3", maxTicksLimit: useDaily ? 15 : 10 },
              grid: { color: "rgba(255,255,255,0.1)" },
            },
            y: {
              ticks: {
                color: "#b3b3b3",
                callback: (value) =>
                  isCurrency ? formatCurrency(value) : Math.round(value),
              },
              grid: { color: "rgba(255,255,255,0.1)" },
            },
          },
          plugins: {
            legend: {
              labels: { color: "#f8f9fa", padding: 20, usePointStyle: true },
            },
            tooltip: {
              backgroundColor: "rgba(42, 42, 43, 0.9)",
              titleColor: "#f8f9fa",
              bodyColor: "#f8f9fa",
              borderColor: "#3a3a3b",
              borderWidth: 1,
              callbacks: {
                label: (context) =>
                  `${context.dataset.label}: ${
                    isCurrency
                      ? formatCurrency(context.parsed.y)
                      : context.parsed.y
                  }`,
              },
            },
          },
        };
      }

      function formatCurrency(amount) {
        if (typeof amount !== "number") return amount;
        if (amount >= 1e12) return `${(amount / 1e12).toFixed(2)}T`;
        if (amount >= 1e9) return `${(amount / 1e9).toFixed(2)}B`;
        if (amount >= 1e6) return `${(amount / 1e6).toFixed(2)}M`;
        if (amount >= 1e3) return `${(amount / 1e3).toFixed(2)}K`;
        return amount.toFixed(2);
      }
    </script>
  </body>
</html>
