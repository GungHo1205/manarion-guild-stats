<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guild Stats Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-primary: #0a0a0b;
        --bg-secondary: #1a1a1b;
        --bg-tertiary: #2a2a2b;
        --text-primary: #f8f9fa;
        --text-secondary: #b3b3b3;
        --accent: #4a9eff;
        --border: #3a3a3b;
        --shadow: rgba(0, 0, 0, 0.5);
        --success: #4ade80;
        --warning: #fbbf24;
        --error: #f87171;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Inter", sans-serif;
        background: var(--bg-primary);
        color: var(--text-primary);
        line-height: 1.6;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .navbar {
        display: flex;
        justify-content: center;
        background: var(--bg-secondary);
        padding: 8px;
        border-radius: 12px;
        margin-bottom: 30px;
        border: 1px solid var(--border);
        flex-wrap: wrap;
      }
      .nav-link {
        color: var(--text-secondary);
        text-decoration: none;
        padding: 10px 20px;
        margin: 5px;
        border-radius: 8px;
        transition: all 0.3s;
        font-weight: 600;
        cursor: pointer;
      }
      .nav-link:hover {
        background-color: var(--bg-tertiary);
        color: var(--text-primary);
      }
      .nav-link.active {
        background-color: var(--accent);
        color: #fff;
      }

      .page-section {
        display: none;
      }
      .page-section.active {
        display: block;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
      }
      .header h1 {
        font-size: 2.5rem;
        font-weight: 800;
      }
      .header p {
        color: var(--text-secondary);
        font-size: 1.1rem;
      }

      .stats-overview {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
      }
      .stat-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 25px;
        text-align: center;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .stat-card h3 {
        font-size: 2.2rem;
        font-weight: 700;
        margin-bottom: 8px;
      }
      .stat-card p {
        color: var(--text-secondary);
        font-size: 0.9rem;
        font-weight: 500;
        margin-bottom: 8px;
      }
      .stat-card .sub-text {
        font-size: 0.85rem;
        color: var(--text-secondary);
        min-height: 1.2em;
      }
      .stat-card .approximation-note {
        font-size: 0.7rem;
        color: var(--text-secondary);
        opacity: 0.6;
        margin-top: 12px;
      }

      .controls {
        margin-bottom: 30px;
        display: flex;
        gap: 20px;
        align-items: center;
        flex-wrap: wrap;
      }
      .search-box {
        flex: 1;
        max-width: 400px;
        position: relative;
      }
      .search-box input {
        width: 100%;
        padding: 12px 20px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-size: 1rem;
      }
      .last-update {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-left: auto;
      }
      .data-freshness {
        font-size: 0.75rem;
        margin-top: 4px;
      }
      .fresh-data {
        color: var(--success);
      }
      .stale-data {
        color: var(--warning);
      }

      .guild-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
        gap: 25px;
      }
      .guild-card {
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 15px;
        padding: 25px;
      }
      .guild-name {
        font-size: 1.3rem;
        font-weight: 600;
      }
      .level-info {
        display: flex;
        justify-content: space-around;
        margin-top: 15px;
      }
      .level-item {
        text-align: center;
      }
      .level-label {
        font-size: 0.85rem;
        color: var(--text-secondary);
      }
      .level-value {
        font-size: 2rem;
        font-weight: 700;
      }
      .daily-change {
        font-size: 0.8rem;
        font-weight: 600;
      }
      .daily-change.positive {
        color: var(--success);
      }

      .loading,
      .error {
        text-align: center;
        padding: 60px;
        font-size: 1.2rem;
      }
      .error {
        color: var(--error);
      }

      .chart-container {
        background: var(--bg-secondary);
        border-radius: 15px;
        padding: 25px;
        border: 1px solid var(--border);
      }
      .chart-header {
        text-align: center;
        margin-bottom: 30px;
      }
      .chart-header h1 {
        font-size: 2.2rem;
        font-weight: 700;
      }
      .chart-header p {
        color: var(--text-secondary);
        font-size: 1rem;
      }

      .chart-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 25px;
      }
      .control-group {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .chart-controls button {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px 14px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.3s;
      }
      .chart-controls button:hover {
        border-color: var(--accent);
      }
      .chart-controls button.active {
        background-color: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .chart-canvas-container {
        position: relative;
        height: 450px;
        margin-top: 20px;
      }

      .multiselect-dropdown {
        position: relative;
        min-width: 250px;
      }
      .multiselect-dropdown-btn {
        background: var(--bg-tertiary);
        width: 100%;
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid var(--border);
        cursor: pointer;
        text-align: left;
        font-weight: 500;
        color: var(--text-primary);
      }
      .multiselect-dropdown-list {
        display: none;
        position: absolute;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 8px;
        width: 100%;
        z-index: 10;
        max-height: 300px;
        overflow-y: auto;
        padding: 8px;
        margin-top: 5px;
        box-shadow: 0 4px 12px var(--shadow);
      }
      .multiselect-dropdown-list label {
        display: block;
        padding: 8px;
        border-radius: 4px;
        cursor: pointer;
        color: var(--text-primary);
      }
      .multiselect-dropdown-list label:hover {
        background-color: var(--bg-tertiary);
      }
      .multiselect-dropdown-list input {
        margin-right: 10px;
      }

      .item-selector {
        position: relative;
        min-width: 300px;
      }
      .item-select-btn {
        background: var(--bg-tertiary);
        width: 100%;
        padding: 10px 15px;
        border-radius: 8px;
        border: 1px solid var(--border);
        cursor: pointer;
        text-align: left;
        font-weight: 500;
        color: var(--text-primary);
      }
      .item-select-dropdown {
        display: none;
        position: absolute;
        background: var(--bg-secondary);
        border: 1px solid var(--border);
        border-radius: 8px;
        width: 100%;
        z-index: 10;
        max-height: 400px;
        overflow-y: auto;
        padding: 8px;
        margin-top: 5px;
        box-shadow: 0 4px 12px var(--shadow);
      }
      .item-select-dropdown input {
        width: 100%;
        background: var(--bg-tertiary);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 6px;
        color: var(--text-primary);
        margin-bottom: 8px;
      }
      .item-category {
        margin-bottom: 12px;
      }
      .category-header {
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--accent);
        padding: 8px;
        background: var(--bg-tertiary);
        border-radius: 4px;
        margin-bottom: 4px;
      }
      .item-option {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        color: var(--text-primary);
        font-size: 0.85rem;
      }
      .item-option:hover {
        background: var(--bg-tertiary);
      }

      .chart-loading {
        text-align: center;
        padding: 100px;
        color: var(--text-secondary);
        font-size: 1.1rem;
      }

      @media (max-width: 768px) {
        .navbar {
          justify-content: flex-start;
        }
        .chart-controls {
          flex-direction: column;
          align-items: stretch;
        }
        .control-group {
          justify-content: center;
        }
        .item-selector {
          min-width: auto;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav class="navbar">
        <a class="nav-link active" data-section="dashboard">Dashboard</a>
        <a class="nav-link" data-section="nexus-charts">Nexus Progress</a>
        <a class="nav-link" data-section="study-charts">Study Progress</a>
        <a class="nav-link" data-section="item-prices">Item Prices</a>
      </nav>

      <!-- Dashboard Section -->
      <div id="dashboard" class="page-section active">
        <header class="header">
          <h1>Guild Stats Dashboard</h1>
          <p>Real-time guild progression tracking</p>
        </header>
        <div class="stats-overview">
          <div class="stat-card">
            <h3 id="stat-avg-nexus">-</h3>
            <p>Avg Nexus Level</p>
            <div id="stat-avg-nexus-progress" class="sub-text"></div>
          </div>
          <div class="stat-card">
            <h3 id="stat-avg-study">-</h3>
            <p>Avg Study Level</p>
            <div id="stat-avg-study-progress" class="sub-text"></div>
          </div>
          <div class="stat-card">
            <h3 id="stat-levels-gained">-</h3>
            <p>Levels Gained Today</p>
            <div class="sub-text"></div>
          </div>
          <div class="stat-card">
            <h3 id="stat-codex-used">-</h3>
            <p>Total Codex Used (Daily)</p>
            <div class="sub-text"></div>
            <div class="approximation-note">
              Approximation without Ethereal Refinery
            </div>
          </div>
          <div class="stat-card">
            <h3 id="stat-dust-spent">-</h3>
            <p>Dust Spent on Codex (Daily)</p>
            <div id="stat-dust-spent-price" class="sub-text"></div>
            <div class="approximation-note">
              Approximation without Ethereal Refinery
            </div>
          </div>
        </div>
        <div class="controls">
          <div class="search-box">
            <input
              type="text"
              id="searchInput"
              placeholder="Search guilds..."
            />
          </div>
          <div class="last-update" id="lastUpdate">
            <div>Loading...</div>
            <div id="dataFreshness" class="data-freshness"></div>
          </div>
        </div>
        <div id="loading" class="loading">Loading guild data...</div>
        <div id="error" class="error" style="display: none">
          Failed to load data.
        </div>
        <div id="guildGrid" class="guild-grid" style="display: none"></div>
      </div>

      <!-- Nexus Chart Section -->
      <div id="nexus-charts" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Nexus Level Progression</h1>
            <p>Track guild nexus level changes over time</p>
          </div>
          <div class="chart-controls">
            <div class="multiselect-dropdown">
              <button
                id="nexusGuildSelectorBtn"
                class="multiselect-dropdown-btn"
              >
                Loading guilds...
              </button>
              <div
                id="nexusGuildSelectorList"
                class="multiselect-dropdown-list"
              ></div>
            </div>
            <div class="control-group">
              <button
                class="chart-timespan-btn active"
                data-chart="nexus"
                data-hours="24"
              >
                1D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="nexus"
                data-hours="168"
              >
                7D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="nexus"
                data-hours="720"
              >
                30D
              </button>
            </div>
          </div>
          <div id="nexusChartLoading" class="chart-loading">
            Loading chart data...
          </div>
          <div class="chart-canvas-container" style="display: none">
            <canvas id="guildNexusChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Study Chart Section -->
      <div id="study-charts" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Study Level Progression</h1>
            <p>Track guild study level changes over time</p>
          </div>
          <div class="chart-controls">
            <div class="multiselect-dropdown">
              <button
                id="studyGuildSelectorBtn"
                class="multiselect-dropdown-btn"
              >
                Loading guilds...
              </button>
              <div
                id="studyGuildSelectorList"
                class="multiselect-dropdown-list"
              ></div>
            </div>
            <div class="control-group">
              <button
                class="chart-timespan-btn active"
                data-chart="study"
                data-hours="24"
              >
                1D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="study"
                data-hours="168"
              >
                7D
              </button>
              <button
                class="chart-timespan-btn"
                data-chart="study"
                data-hours="720"
              >
                30D
              </button>
            </div>
          </div>
          <div id="studyChartLoading" class="chart-loading">
            Loading chart data...
          </div>
          <div class="chart-canvas-container" style="display: none">
            <canvas id="guildStudyChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Item Prices Section -->
      <div id="item-prices" class="page-section">
        <div class="chart-container">
          <div class="chart-header">
            <h1>Item Price History</h1>
            <p>Monitor market prices for tradeable items</p>
          </div>
          <div class="chart-controls">
            <div class="item-selector">
              <button id="itemSelectBtn" class="item-select-btn">
                Loading items...
              </button>
              <div id="itemSelectDropdown" class="item-select-dropdown">
                <input
                  type="text"
                  id="itemSearchInput"
                  placeholder="Search items..."
                />
                <div id="itemList"></div>
              </div>
            </div>
            <div class="control-group">
              <button class="market-timespan-btn active" data-hours="24">
                1D
              </button>
              <button class="market-timespan-btn" data-hours="168">7D</button>
              <button class="market-timespan-btn" data-hours="720">30D</button>
            </div>
          </div>
          <div id="marketChartLoading" class="chart-loading">
            Loading chart data...
          </div>
          <div class="chart-canvas-container" style="display: none">
            <canvas id="marketPriceChart"></canvas>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Global State
      let allGuildsData = [];
      let historicalData = {};
      let guildNexusChart, guildStudyChart, marketPriceChart;
      let dataLoaded = false;
      const chartColors = [
        "#ec4899",
        "#38bdf8",
        "#4ade80",
        "#a78bfa",
        "#fde047",
        "#fb923c",
        "#f87171",
        "#34d399",
        "#fbbf24",
        "#c084fc",
      ];

      // Check if API is available
      async function checkApiAvailability() {
        try {
          const response = await fetch(`${API_BASE_URL}/guild-data`);
          apiAvailable = response.ok;
          if (!apiAvailable) {
            document.getElementById("apiNotice").style.display = "block";
          }
          return apiAvailable;
        } catch (error) {
          console.log("API not available, will try JSON fallback");
          document.getElementById("apiNotice").style.display = "block";
          return false;
        }
      }

      // API or JSON fetch wrapper
      async function fetchData(endpoint, fallbackFile = null) {
        console.log(
          `Attempting to fetch: ${endpoint}, fallback: ${fallbackFile}`
        );

        if (apiAvailable) {
          try {
            const response = await fetch(`${API_BASE_URL}/${endpoint}`);
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully fetched from API: ${endpoint}`);
              return data;
            } else {
              console.log(
                `API response not OK for ${endpoint}: ${response.status}`
              );
            }
          } catch (error) {
            console.error(`API fetch failed for ${endpoint}:`, error);
          }
        }

        // Fallback to JSON files
        if (fallbackFile) {
          try {
            const response = await fetch(
              `${fallbackFile}?v=${new Date().getTime()}`
            );
            if (response.ok) {
              const data = await response.json();
              console.log(`Successfully fetched from JSON: ${fallbackFile}`);
              return data;
            } else {
              console.log(
                `JSON fetch failed for ${fallbackFile}: ${response.status}`
              );
            }
          } catch (error) {
            console.error(`JSON fallback failed for ${fallbackFile}:`, error);
          }
        }

        // Return empty data structure instead of throwing error
        console.warn(
          `No data available for ${endpoint}, returning empty structure`
        );
        if (endpoint.includes("historical-data")) {
          return {
            guild_history: {},
            item_prices: {},
            item_categories: {
              Essentials: ["Codex"],
              Resources: ["Fish", "Wood", "Iron"],
            },
          };
        }
        return {};
      }

      // Initialization
      document.addEventListener("DOMContentLoaded", () => {
        loadAllData();
        setupEventListeners();
      });

      async function loadAllData() {
        try {
          console.log("Starting data load...");

          const [dailyBaseline, guildData, historicalDataRes] =
            await Promise.all([
              fetchData("daily-baseline", "./daily-baseline.json").catch(
                () => ({})
              ),
              fetchData("guild-data", "./guild-data.json").catch(() => ({
                guilds: [],
              })),
              fetchData(
                "historical-data?hours=720",
                "./historical-data.json"
              ).catch(() => ({
                guild_history: {},
                item_prices: {},
                item_categories: {
                  Essentials: ["Codex"],
                  Resources: ["Fish", "Wood", "Iron"],
                },
              })),
            ]);

          allGuildsData = guildData.guilds || [];
          console.log(`Loaded ${allGuildsData.length} guilds`);

          updateDashboard(dailyBaseline, guildData);
          renderGuilds();

          historicalData = historicalDataRes || {
            guild_history: {},
            item_prices: {},
            item_categories: {},
          };

          console.log("Historical data loaded:", {
            guilds: Object.keys(historicalData.guild_history || {}).length,
            items: Object.keys(historicalData.item_prices || {}).length,
            categories: Object.keys(historicalData.item_categories || {})
              .length,
          });

          populateGuildSelectors();
          populateItemSelector();

          document.getElementById("loading").style.display = "none";
          document.getElementById("guildGrid").style.display = "grid";
          dataLoaded = true;

          // Hide loading indicators on chart pages
          document.getElementById("nexusChartLoading").style.display = "none";
          document.getElementById("studyChartLoading").style.display = "none";
          document.getElementById("marketChartLoading").style.display = "none";
          document.getElementById("leaderboardLoading").style.display = "none";

          // Load leaderboard data
          updateLeaderboard("codex");

          console.log("Data loading completed successfully");
        } catch (error) {
          console.error("Error loading data:", error);
          document.getElementById("loading").style.display = "none";
          document.getElementById("error").style.display = "block";
          document.getElementById(
            "error"
          ).textContent = `Failed to load data: ${error.message}`;
        }
      }

      function setupEventListeners() {
        document
          .querySelectorAll(".nav-link")
          .forEach((link) => link.addEventListener("click", handleNavigation));
        document
          .getElementById("searchInput")
          .addEventListener("input", renderGuilds);

        // Chart timespan buttons
        document.querySelectorAll(".chart-timespan-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const chartType = e.target.dataset.chart;
            const section = e.target.closest(".page-section").id;
            document
              .querySelectorAll(`#${section} .chart-timespan-btn`)
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            if (chartType) updateGuildChart(chartType);
          });
        });

        // Market timespan buttons
        document.querySelectorAll(".market-timespan-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            document
              .querySelectorAll(".market-timespan-btn")
              .forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            updateMarketChart();
          });
        });

        // Setup dropdowns
        setupDropdown("nexusGuildSelectorBtn", "nexusGuildSelectorList", () =>
          updateGuildChart("nexus")
        );
        setupDropdown("studyGuildSelectorBtn", "studyGuildSelectorList", () =>
          updateGuildChart("study")
        );
        setupDropdown("itemSelectBtn", "itemSelectDropdown");
        document
          .getElementById("itemSearchInput")
          .addEventListener("input", filterItems);
      }

      function setupDropdown(btnId, listId, onChangeCallback) {
        const btn = document.getElementById(btnId);
        const list = document.getElementById(listId);
        btn.addEventListener("click", () => {
          const isVisible = list.style.display === "block";
          // Close all dropdowns first
          document
            .querySelectorAll(
              ".multiselect-dropdown-list, .item-select-dropdown"
            )
            .forEach((d) => (d.style.display = "none"));
          list.style.display = isVisible ? "none" : "block";
        });
        if (onChangeCallback) list.addEventListener("change", onChangeCallback);
        document.addEventListener("click", (e) => {
          if (!btn.contains(e.target) && !list.contains(e.target)) {
            list.style.display = "none";
          }
        });
      }

      function handleNavigation(e) {
        e.preventDefault();
        const targetId = e.target.getAttribute("data-section");
        console.log(`Navigating to: ${targetId}`);

        // Update nav links
        document
          .querySelectorAll(".nav-link")
          .forEach((l) => l.classList.remove("active"));
        e.target.classList.add("active");

        // Show target page, hide others
        document
          .querySelectorAll(".page-section")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById(targetId).classList.add("active");

        // Load charts when navigating to chart pages - but only if data is loaded
        if (dataLoaded) {
          try {
            if (targetId === "nexus-charts" && !guildNexusChart) {
              setTimeout(() => updateGuildChart("nexus"), 100);
            }
            if (targetId === "study-charts" && !guildStudyChart) {
              setTimeout(() => updateGuildChart("study"), 100);
            }
            if (targetId === "item-prices") {
              setTimeout(() => {
                const selectedItem =
                  document.getElementById("itemSelectBtn").dataset.selected;
                console.log(
                  `Item prices page loaded, selected item: ${selectedItem}`
                );
                if (selectedItem && selectedItem !== "No items available") {
                  updateMarketChart();
                } else {
                  console.log("No valid item selected for market chart");
                  // Show message instead of trying to load chart
                  document.querySelector(
                    "#item-prices .chart-canvas-container"
                  ).style.display = "none";
                  document.getElementById("marketChartLoading").style.display =
                    "block";
                  document.getElementById("marketChartLoading").textContent =
                    "Select an item to view price history";
                }
              }, 100);
            }
            if (targetId === "leaderboards") {
              document.getElementById("leaderboardContent").style.display =
                "grid";
            }
          } catch (error) {
            console.error(`Error in navigation to ${targetId}:`, error);
          }
        } else {
          console.log("Data not loaded yet, skipping chart initialization");
        }
      }

      // Favorite Guilds Functions
      function toggleFavorite(guildName) {
        const index = favoriteGuilds.indexOf(guildName);
        if (index > -1) {
          favoriteGuilds.splice(index, 1);
        } else {
          favoriteGuilds.push(guildName);
        }
        localStorage.setItem("favoriteGuilds", JSON.stringify(favoriteGuilds));
        renderGuilds();
        populateGuildSelectors();
      }

      function isFavorite(guildName) {
        return favoriteGuilds.includes(guildName);
      }

      function sortGuildsByFavorite(guilds) {
        return guilds.sort((a, b) => {
          const aFav = isFavorite(a.GuildName);
          const bFav = isFavorite(b.GuildName);

          if (aFav && !bFav) return -1;
          if (!aFav && bFav) return 1;

          return (b.NexusLevel || 0) - (a.NexusLevel || 0);
        });
      }

      function updateDashboard(dailyBaseline, data) {
        const { guilds, dustSpending, lastUpdated, baselineCreatedAt } = data;
        if (!guilds || guilds.length === 0) return;

        const avg = (key) =>
          guilds.reduce((sum, g) => sum + (g[key] || 0), 0) / guilds.length;
        const sum = (key) => guilds.reduce((sum, g) => sum + (g[key] || 0), 0);

        document.getElementById("stat-avg-nexus").textContent =
          avg("NexusLevel").toFixed(1);
        document.getElementById(
          "stat-avg-nexus-progress"
        ).innerHTML = `<span class="daily-change positive">+${avg(
          "NexusProgress"
        ).toFixed(1)} Today</span>`;

        document.getElementById("stat-avg-study").textContent =
          avg("StudyLevel").toFixed(1);
        document.getElementById(
          "stat-avg-study-progress"
        ).innerHTML = `<span class="daily-change positive">+${avg(
          "StudyProgress"
        ).toFixed(1)} Today</span>`;

        document.getElementById("stat-levels-gained").textContent =
          sum("NexusProgress") + sum("StudyProgress");
        document.getElementById("stat-codex-used").textContent = (
          dustSpending.total_codex || 0
        ).toLocaleString();
        document.getElementById("stat-dust-spent").textContent =
          dustSpending.formatted_dust || "0.00";
        document.getElementById("stat-dust-spent-price").textContent = `@ ${
          dustSpending.formatted_price || "N/A"
        } per Codex`;

        const lastUpdateTime = new Date(lastUpdated).toLocaleString();
        document.getElementById("lastUpdate").innerHTML = `
          <div>Last updated: ${lastUpdateTime}</div>
          <div id="dataFreshness" class="data-freshness"></div>
        `;

        // Show data freshness indicators
        const freshnessDiv = document.getElementById("dataFreshness");
        if (dataFreshness) {
          const guildStatus = dataFreshness.guild_data_fresh
            ? '<span class="fresh-data">✓ Guild data fresh</span>'
            : '<span class="stale-data">⚠ Using cached guild data</span>';
          const marketStatus = dataFreshness.market_data_fresh
            ? '<span class="fresh-data">✓ Market data fresh</span>'
            : '<span class="stale-data">⚠ Using cached market data</span>';
          freshnessDiv.innerHTML = `${guildStatus} | ${marketStatus}`;
        }
      }

      function renderGuilds() {
        const searchTerm = document
          .getElementById("searchInput")
          .value.toLowerCase();
        const filtered = allGuildsData.filter((g) =>
          g.GuildName.toLowerCase().includes(searchTerm)
        );
        const grid = document.getElementById("guildGrid");

        if (filtered.length === 0) {
          grid.innerHTML =
            "<p style='text-align: center; color: var(--text-secondary); grid-column: 1/-1;'>No guilds found.</p>";
          return;
        }

        grid.innerHTML = filtered
          .map(
            (g) => `
                <div class="guild-card">
                    <div class="guild-name">${g.GuildName}</div>
                    <div class="level-info">
                        <div class="level-item">
                            <div class="level-label">Nexus</div>
                            <div class="level-value">${g.NexusLevel || 0}</div>
                            <div class="daily-change positive">+${
                              g.NexusProgress || 0
                            }</div>
                        </div>
                        <div class="level-item">
                            <div class="level-label">Study</div>
                            <div class="level-value">${g.StudyLevel || 0}</div>
                            <div class="daily-change positive">+${
                              g.StudyProgress || 0
                            }</div>
                        </div>
                    </div>
                </div>
            `
          )
          .join("");
      }

      function populateGuildSelectors() {
        const guildNames = Object.keys(
          historicalData.guild_history || {}
        ).sort();
        if (guildNames.length === 0) return;

        ["nexus", "study"].forEach((type) => {
          const list = document.getElementById(`${type}GuildSelectorList`);
          list.innerHTML = guildNames
            .map(
              (name, i) =>
                `<label><input type="checkbox" value="${name}" ${
                  i < 5 ? "checked" : ""
                }> ${name}</label>`
            )
            .join("");
          updateSelectedGuildCount(type);
        });
      }

      function updateSelectedGuildCount(type) {
        const list = document.getElementById(`${type}GuildSelectorList`);
        const btn = document.getElementById(`${type}GuildSelectorBtn`);
        const count = list.querySelectorAll("input:checked").length;
        btn.textContent = `${count} Guild${count !== 1 ? "s" : ""} Selected`;
      }

      function updateGuildChart(chartType) {
        if (!historicalData.guild_history) return;

        updateSelectedGuildCount(chartType);
        const selectedGuilds = Array.from(
          document.querySelectorAll(
            `#${chartType}GuildSelectorList input:checked`
          )
        ).map((cb) => cb.value);
        const hours = parseInt(
          document.querySelector(
            `#${chartType}-charts .chart-timespan-btn.active`
          ).dataset.hours
        );
        const cutoff = new Date(Date.now() - hours * 3600 * 1000);

        const datasets = selectedGuilds.map((name, i) => {
          const guildData = historicalData.guild_history[name] || [];
          const filteredData = guildData
            .filter((d) => new Date(d.timestamp) >= cutoff)
            .map((d) => ({ x: d.timestamp, y: d[chartType] }));

          return {
            label: name,
            data: filteredData,
            borderColor: chartColors[i % chartColors.length],
            backgroundColor: chartColors[i % chartColors.length] + "20",
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 4,
          };
        });

        const canvasId =
          chartType === "nexus" ? "guildNexusChart" : "guildStudyChart";
        const containerSelector = `#${chartType}-charts .chart-canvas-container`;

        // Show canvas container
        document.querySelector(containerSelector).style.display = "block";

        let chartInstance =
          chartType === "nexus" ? guildNexusChart : guildStudyChart;
        if (chartInstance) chartInstance.destroy();

        const ctx = document.getElementById(canvasId).getContext("2d");
        chartInstance = new Chart(ctx, {
          type: "line",
          data: { datasets },
          options: getChartOptions(hours, false),
        });

        if (chartType === "nexus") guildNexusChart = chartInstance;
        else guildStudyChart = chartInstance;
      }

      function populateItemSelector() {
        console.log("Populating item selector...");

        const itemCategories = historicalData.item_categories || {};
        const items = historicalData.item_prices || {};

        console.log("Available items:", Object.keys(items));
        console.log("Item categories:", itemCategories);

        if (Object.keys(items).length === 0) {
          console.log("No items available, showing placeholder");
          document.getElementById("itemSelectBtn").textContent =
            "No items available";
          return;
        }

        const itemList = document.getElementById("itemList");

        // Define the display order for categories
        const categoryOrder = [
          "Essentials",
          "Resources",
          "Spell Tomes",
          "Orbs/Upgrades",
          "Herbs",
          "Enchanting Reagents",
          "Enchanting Formulas",
          "Special",
        ];

        let html = "";
        let hasItems = false;

        categoryOrder.forEach((categoryName) => {
          const categoryItems = itemCategories[categoryName] || [];
          const availableItems = categoryItems.filter((item) => items[item]);

          if (availableItems.length > 0) {
            hasItems = true;
            html += `<div class="item-category">
        <div class="category-header">${categoryName}</div>`;
            availableItems.forEach((itemName) => {
              html += `<div class="item-option" data-item="${itemName}">${itemName}</div>`;
            });

            html += `</div>`;
          }
        });

        // If no categorized items, show all available items
        if (!hasItems && Object.keys(items).length > 0) {
          html = `<div class="item-category">
      <div class="category-header">Available Items</div>`;
          Object.keys(items).forEach((itemName) => {
            html += `<div class="item-option" data-item="${itemName}">${itemName}</div>`;
          });
          html += `</div>`;
          hasItems = true;
        }

        if (!hasItems) {
          html =
            '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No items available</div>';
        }

        itemList.innerHTML = html;

        document.querySelectorAll(".item-option").forEach((option) => {
          option.addEventListener("click", () => {
            console.log(`Selected item: ${option.dataset.item}`);
            document.getElementById("itemSelectBtn").textContent =
              option.textContent;
            document.getElementById("itemSelectBtn").dataset.selected =
              option.dataset.item;
            document.getElementById("itemSelectDropdown").style.display =
              "none";
            updateMarketChart();
          });
        });

        // Select Codex by default
        const firstOption = document.querySelector(".item-option");
        if (firstOption) {
          document.getElementById("itemSelectBtn").textContent =
            firstOption.textContent;
          document.getElementById("itemSelectBtn").dataset.selected =
            firstOption.dataset.item;
          console.log(`Default item selected: ${firstOption.dataset.item}`);
        } else {
          document.getElementById("itemSelectBtn").textContent =
            "No items available";
          console.log("No items available for selection");
        }
      }

      function populatePredictorItemSelector() {
        // Same logic as populateItemSelector but for predictor
        const itemCategories = historicalData.item_categories || {};
        const items = historicalData.item_prices || {};

        if (Object.keys(items).length === 0) return;

        const itemList = document.getElementById("predictorItemList");
        const categoryOrder = [
          "Essentials",
          "Resources",
          "Spell Tomes",
          "Orbs/Upgrades",
          "Herbs",
          "Enchanting Reagents",
          "Enchanting Formulas",
          "Special",
        ];

        let html = "";
        categoryOrder.forEach((categoryName) => {
          const categoryItems = itemCategories[categoryName] || [];
          const availableItems = categoryItems.filter((item) => items[item]);

          if (availableItems.length > 0) {
            html += `<div class="item-category">
              <div class="category-header">${categoryName}</div>`;
            availableItems.forEach((itemName) => {
              html += `<div class="item-option" data-item="${itemName}">${itemName}</div>`;
            });
            html += `</div>`;
          }
        });

        itemList.innerHTML = html;

        document
          .querySelectorAll("#predictorItemList .item-option")
          .forEach((option) => {
            option.addEventListener("click", () => {
              document.getElementById("predictorItemSelectBtn").textContent =
                option.textContent;
              document.getElementById(
                "predictorItemSelectBtn"
              ).dataset.selected = option.dataset.item;
              document.getElementById(
                "predictorItemSelectDropdown"
              ).style.display = "none";
              updatePrediction();
            });
          });

        // Select Codex by default
        const defaultOption =
          document.querySelector(
            '#predictorItemList .item-option[data-item="Codex"]'
          ) || document.querySelector("#predictorItemList .item-option");
        if (defaultOption) {
          document.getElementById("predictorItemSelectBtn").textContent =
            defaultOption.textContent;
          document.getElementById("predictorItemSelectBtn").dataset.selected =
            defaultOption.dataset.item;
        }
      }

      function filterItems() {
        const term = document
          .getElementById("itemSearchInput")
          .value.toLowerCase();
        document.querySelectorAll(".item-option").forEach((opt) => {
          const matches = opt.textContent.toLowerCase().includes(term);
          opt.style.display = matches ? "block" : "none";
        });

        // Hide/show category headers based on whether they have visible items
        document.querySelectorAll(".item-category").forEach((category) => {
          const visibleItems = category.querySelectorAll(
            '.item-option[style="display: block;"], .item-option:not([style*="display: none"])'
          );
          category.style.display = visibleItems.length > 0 ? "block" : "none";
        });
      }

      function filterPredictorItems() {
        const term = document
          .getElementById("predictorItemSearchInput")
          .value.toLowerCase();
        document
          .querySelectorAll("#predictorItemList .item-option")
          .forEach((opt) => {
            const matches = opt.textContent.toLowerCase().includes(term);
            opt.style.display = matches ? "block" : "none";
          });

        document
          .querySelectorAll("#predictorItemList .item-category")
          .forEach((category) => {
            const visibleItems = category.querySelectorAll(
              '.item-option[style="display: block;"], .item-option:not([style*="display: none"])'
            );
            category.style.display = visibleItems.length > 0 ? "block" : "none";
          });
      }

      async function updateMarketChart() {
        const selectedItem =
          document.getElementById("itemSelectBtn").dataset.selected;

        // Safety check - don't proceed if no item is selected
        if (!selectedItem) {
          console.log("No item selected for market chart");
          return;
        }

        const hours = parseInt(
          document.querySelector("#item-prices .market-timespan-btn.active")
            ?.dataset.hours || "24" // Add fallback value
        );

        // Fetch fresh market data if API is available
        if (apiAvailable) {
          try {
            const marketPrices = await fetchData(
              `market-prices?hours=${hours}`
            );
            if (marketPrices) {
              historicalData.item_prices = {
                ...historicalData.item_prices,
                ...marketPrices,
              };
            }
          } catch (error) {
            console.error("Failed to fetch fresh market data:", error);
          }
        }

        if (!historicalData.item_prices?.[selectedItem]) {
          console.log(`No price data available for ${selectedItem}`);
          return;
        }

        // Rest of your existing updateMarketChart code...
        const cutoff = new Date(Date.now() - hours * 3600 * 1000);
        const prices = historicalData.item_prices[selectedItem].prices.filter(
          (p) => new Date(p.timestamp) >= cutoff
        );

        if (prices.length === 0) {
          console.log(`No recent price data for ${selectedItem}`);
          return;
        }

        const aggregation = document.getElementById("marketAggregation").value;
        const useDaily =
          aggregation === "daily" || (aggregation === "auto" && hours >= 168);

        if (useDaily && prices.length > 0) {
          prices = aggregateMarketDataByDay(prices);
        }

        const datasets = [
          {
            label: "Buy Price",
            data: prices.map((p) => ({ x: p.timestamp, y: p.buy })),
            borderColor: "#4ade80",
            backgroundColor: "#4ade8020",
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 4,
          },
          {
            label: "Sell Price",
            data: prices.map((p) => ({ x: p.timestamp, y: p.sell })),
            borderColor: "#f87171",
            backgroundColor: "#f8717120",
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 4,
          },
        ];

        // Show canvas container
        document.querySelector(
          "#item-prices .chart-canvas-container"
        ).style.display = "block";

        if (marketPriceChart) marketPriceChart.destroy();

        const ctx = document
          .getElementById("marketPriceChart")
          .getContext("2d");
        marketPriceChart = new Chart(ctx, {
          type: "line",
          data: { datasets },
          options: getChartOptions(hours, true),
        });
      }

      // Price Prediction Functions
      function updatePrediction() {
        const selectedItem = document.getElementById("predictorItemSelectBtn")
          .dataset.selected;
        if (!selectedItem || !historicalData.item_prices?.[selectedItem]) {
          document.getElementById("predictionLoading").style.display = "block";
          document.getElementById("predictionResults").style.display = "none";
          return;
        }

        const days = parseInt(
          document.querySelector(".predictor-period-btn.active").dataset.days
        );
        const cutoff = new Date(Date.now() - days * 24 * 3600 * 1000);
        const prices = historicalData.item_prices[selectedItem].prices.filter(
          (p) => new Date(p.timestamp) >= cutoff
        );

        if (prices.length < 2) return;

        const prediction = calculatePrediction(prices);
        displayPrediction(selectedItem, prediction, prices);
      }

      function calculatePrediction(prices) {
        // Calculate current and historical averages
        const recent = prices.slice(-24); // Last 24 hours
        const currentAvg =
          recent.reduce((sum, p) => sum + (p.buy + p.sell) / 2, 0) /
          recent.length;

        // Calculate trend using linear regression
        const values = prices.map((p, i) => ({
          x: i,
          y: (p.buy + p.sell) / 2,
        }));
        const n = values.length;
        const sumX = values.reduce((sum, v) => sum + v.x, 0);
        const sumY = values.reduce((sum, v) => sum + v.y, 0);
        const sumXY = values.reduce((sum, v) => sum + v.x * v.y, 0);
        const sumX2 = values.reduce((sum, v) => sum + v.x * v.x, 0);

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;

        // Predict next price point
        const predictedPrice = slope * n + intercept;
        const priceChange = ((predictedPrice - currentAvg) / currentAvg) * 100;

        // Determine trend direction
        let trend = "stable";
        if (Math.abs(priceChange) > 5) {
          trend = priceChange > 0 ? "up" : "down";
        }

        return {
          currentPrice: currentAvg,
          predictedPrice: predictedPrice,
          priceChange: priceChange,
          trend: trend,
        };
      }

      function displayPrediction(itemName, prediction, prices) {
        document.getElementById("predictionLoading").style.display = "none";
        document.getElementById("predictionResults").style.display = "block";

        document.getElementById("currentPrice").textContent = formatCurrency(
          prediction.currentPrice
        );
        document.getElementById("predictedPrice").textContent = formatCurrency(
          prediction.predictedPrice
        );

        const changeElement = document.getElementById("priceChange");
        changeElement.textContent = `${
          prediction.priceChange >= 0 ? "+" : ""
        }${prediction.priceChange.toFixed(1)}%`;
        changeElement.className = `trend-${prediction.trend}`;

        updatePredictionChart(itemName, prices, prediction);
      }

      function updatePredictionChart(itemName, prices, prediction) {
        const historicalData = prices.map((p) => ({
          x: p.timestamp,
          y: (p.buy + p.sell) / 2,
        }));
        const futureTime = new Date(
          Date.now() + 24 * 3600 * 1000
        ).toISOString();
        const predictionPoint = { x: futureTime, y: prediction.predictedPrice };

        const datasets = [
          {
            label: "Historical Average Price",
            data: historicalData,
            borderColor: "#4a9eff",
            backgroundColor: "#4a9eff20",
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 4,
          },
          {
            label: "Prediction",
            data: [historicalData[historicalData.length - 1], predictionPoint],
            borderColor: "#fbbf24",
            backgroundColor: "#fbbf2440",
            borderDash: [5, 5],
            tension: 0,
            pointRadius: 4,
            pointHoverRadius: 6,
          },
        ];

        if (predictionChart) predictionChart.destroy();

        const ctx = document.getElementById("predictionChart").getContext("2d");
        predictionChart = new Chart(ctx, {
          type: "line",
          data: { datasets },
          options: {
            ...getChartOptions(
              24 *
                parseInt(
                  document.querySelector(".predictor-period-btn.active").dataset
                    .days
                ),
              true,
              false
            ),
            plugins: {
              ...getChartOptions(24, true, false).plugins,
              title: {
                display: true,
                text: `${itemName} Price Prediction`,
                color: "#f8f9fa",
                font: { size: 16, weight: "bold" },
              },
            },
          },
        });
      }

      // Leaderboard Functions
      async function updateLeaderboard(type) {
        document.getElementById("leaderboardContent").style.display = "grid";

        // Directly use the guild data already loaded for the dashboard
        let sortedGuilds = [...allGuildsData];

        let title = "";
        let valueKey = "";
        let formatValue = (val) => val;

        // Sort the data based on the selected leaderboard type
        switch (type) {
          case "codex":
            sortedGuilds.sort(
              (a, b) => (b.TotalCodexCost || 0) - (a.TotalCodexCost || 0)
            );
            title = "Most Codex Spent Today";
            valueKey = "TotalCodexCost";
            formatValue = (val) => (val || 0).toLocaleString() + " Codex";
            break;
          case "nexus":
            sortedGuilds.sort(
              (a, b) => (b.NexusProgress || 0) - (a.NexusProgress || 0)
            );
            title = "Top Nexus Upgrades Today";
            valueKey = "NexusProgress";
            formatValue = (val) => "+" + (val || 0) + " Levels";
            break;
          case "study":
            sortedGuilds.sort(
              (a, b) => (b.StudyProgress || 0) - (a.StudyProgress || 0)
            );
            title = "Top Study Upgrades Today";
            valueKey = "StudyProgress";
            formatValue = (val) => "+" + (val || 0) + " Levels";
            break;
        }

        const guildNameKey = "GuildName"; // Key from the allGuildsData object
        const filteredGuilds = sortedGuilds.filter(
          (g) => (g[valueKey] || 0) > 0
        );

        const content = document.getElementById("leaderboardContent");

        if (filteredGuilds.length === 0) {
          content.innerHTML = `
            <div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 60px;">
              No progress data available for ${title.toLowerCase()}
            </div>
          `;
          return;
        }

        content.innerHTML = filteredGuilds
          .slice(0, 20) // Limit to top 20
          .map((guild, index) => {
            const rank = index + 1;
            let rankClass = "";
            let rankDisplay = rank;

            if (rank === 1) {
              rankClass = "gold";
              rankDisplay = "1st";
            } else if (rank === 2) {
              rankClass = "silver";
              rankDisplay = "2nd";
            } else if (rank === 3) {
              rankClass = "bronze";
              rankDisplay = "3rd";
            }

            const guildName = guild[guildNameKey];
            const guildValue = guild[valueKey] || 0;

            return `
              <div class="leaderboard-item ${
                isFavorite(guildName) ? "favorite" : ""
              }">
                <div class="leaderboard-rank ${rankClass}">${rankDisplay}</div>
                <div class="leaderboard-info">
                  <div class="leaderboard-guild">
                    ${isFavorite(guildName) ? "★ " : ""}${guildName}
                  </div>
                  <div class="leaderboard-stat">
                    <span class="leaderboard-value">${formatValue(
                      guildValue
                    )}</span>
                  </div>
                </div>
              </div>
            `;
          })
          .join("");
      }

      // Aggregation functions
      function aggregateDataByDay(data) {
        const dailyData = {};

        data.forEach((point) => {
          const date = new Date(point.x).toDateString();
          if (!dailyData[date]) {
            dailyData[date] = { values: [], timestamp: point.x };
          }
          dailyData[date].values.push(point.y);
        });

        return Object.values(dailyData)
          .map((day) => ({
            x: day.timestamp,
            y: Math.round(day.values[day.values.length - 1]), // Use last value of the day
          }))
          .sort((a, b) => new Date(a.x) - new Date(b.x));
      }

      function aggregateMarketDataByDay(prices) {
        const dailyData = {};

        prices.forEach((price) => {
          const date = new Date(price.timestamp).toDateString();
          if (!dailyData[date]) {
            dailyData[date] = { buy: [], sell: [], timestamp: price.timestamp };
          }
          dailyData[date].buy.push(price.buy);
          dailyData[date].sell.push(price.sell);
        });

        return Object.values(dailyData)
          .map((day) => ({
            timestamp: day.timestamp,
            buy: Math.round(day.buy[day.buy.length - 1]), // Use last value of the day
            sell: Math.round(day.sell[day.sell.length - 1]),
          }))
          .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      }

      function getChartOptions(hours, isCurrency, useDaily = false) {
        const timeUnit = useDaily ? "day" : hours <= 72 ? "hour" : "day";

        return {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: "index",
          },
          scales: {
            x: {
              type: "time",
              time: {
                unit: hours <= 48 ? "hour" : "day",
                displayFormats: {
                  hour: "MMM dd HH:mm",
                  day: "MMM dd",
                },
              },
              ticks: {
                color: "#b3b3b3",
                maxTicksLimit: 10,
              },
              grid: {
                color: "rgba(255,255,255,0.1)",
              },
            },
            y: {
              ticks: {
                color: "#b3b3b3",
                callback: function (value) {
                  return isCurrency ? formatCurrency(value) : Math.round(value);
                },
              },
              grid: {
                color: "rgba(255,255,255,0.1)",
              },
            },
          },
          plugins: {
            legend: {
              labels: {
                color: "#f8f9fa",
                padding: 20,
                usePointStyle: true,
              },
            },
            tooltip: {
              backgroundColor: "rgba(42, 42, 43, 0.9)",
              titleColor: "#f8f9fa",
              bodyColor: "#f8f9fa",
              borderColor: "#3a3a3b",
              borderWidth: 1,
              callbacks: {
                label: function (context) {
                  const value = isCurrency
                    ? formatCurrency(context.parsed.y)
                    : context.parsed.y;
                  return `${context.dataset.label}: ${value}`;
                },
              },
            },
          },
        };
      }

      function formatCurrency(amount) {
        if (typeof amount !== "number") return amount;
        if (amount >= 1e12) return `${(amount / 1e12).toFixed(2)}T`;
        if (amount >= 1e9) return `${(amount / 1e9).toFixed(2)}B`;
        if (amount >= 1e6) return `${(amount / 1e6).toFixed(2)}M`;
        if (amount >= 1e3) return `${(amount / 1e3).toFixed(2)}K`;
        return amount.toFixed(2);
      }

      // Auto-refresh data every 5 minutes
      setInterval(() => {
        if (document.visibilityState === "visible") {
          loadAllData();
        }
      }, 5 * 60 * 1000);
    </script>
  </body>
</html>
